{
  "version": 2,
  "activeTab": 3,
  "tabs": [
    {
      "name": "My Shaders",
      "type": "shaders",
      "slots": [
        {
          "shaderCode": "// Audio Visualizer Example\n// Load audio input to iChannel0: File > Use Audio Input (FFT) for Channel 0\n//\n// iChannel0 texture layout (512x2):\n//   Row 0 (y=0.0): FFT frequency spectrum (0-255, bass on left, treble on right)\n//   Row 1 (y=1.0): Waveform / time domain data (centered at 128)\n//  @texture iChannel3 AudioFFT\n//  @param gain float 1.0 [0.0,10.0] \"Gain\"\n//  @param spread float 1.0 [0.0,5.0] \"Gain\"\n//  @param wavepos float 0.5 [0.0,5.0] \"Gain\"\n//  @param wavecol color [0.2,0.8,1.0]\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    // Get audio data\n    float fft = texture(iChannel3, vec2(uv.x * spread, 0.0)).r;      // Frequency spectrum\n    float wave = texture(iChannel3, vec2(uv.x, 1.0)).r;     // Waveform\n\n    // Frequency bars visualization (bottom half)\n    if (uv.y < 0.5) {\n        float barHeight = fft * 0.5;\n        if (uv.y < barHeight) {\n            // Color based on frequency (bass=red, mid=green, treble=blue)\n            vec3 barColor = vec3(1.0 - uv.x, abs(uv.x - 0.5) * 2.0, uv.x);\n            col = barColor * (1.0 - uv.y / barHeight * 0.5);\n        }\n    }\n\n    // Waveform visualization (top half)\n    if (uv.y >= wavepos) {\n        float waveY = 0.75 + (wave - 0.5) * gain; // Center wave in top half\n        float dist = abs(uv.y - waveY);\n        float glow = 0.008 / (dist + 0.008);\n        col += wavecol * glow;\n    }\n\n    // Add some bass-reactive background glow\n    float bass = texture(iChannel3, vec2(0.05, 0.0)).r;\n    col += vec3(0.1, 0.02, 0.15) * bass * 2.0;\n\n    // Circular spectrum visualizer in center\n    vec2 center = uv - 0.5;\n    float angle = atan(center.y, center.x);\n    float radius = length(center);\n    float freqIndex = (angle + 3.14159) / 6.28318; // 0 to 1\n    float freqValue = texture(iChannel3, vec2(freqIndex, 0.0)).r;\n\n    float innerRadius = 0.1;\n    float outerRadius = innerRadius + freqValue * 0.15;\n\n    if (radius > innerRadius && radius < outerRadius) {\n        float intensity = 1.0 - (radius - innerRadius) / (outerRadius - innerRadius);\n        vec3 circleColor = 0.5 + 0.5 * cos(angle + iTime + vec3(0, 2, 4));\n        col += circleColor * intensity * 0.5;\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "gain": 1,
            "spread": 1,
            "wavepos": 0.5,
            "wavecol": [
              0.2,
              0.8,
              1
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// ShaderShow - Default Shader\n// A colorful animated pattern demonstrating Shadertoy uniforms\n// Custom params: // @param name type [default] [min, max] \"description\"\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    // Mouse interaction - brighten area near cursor\n    if (iMouse.z > 0.0) {\n        vec2 mouseUV = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n        float mouseDist = length(uv0 - mouseUV);\n        finalColor += vec3(0.2) * smoothstep(0.5, 0.0, mouseDist);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
          "filePath": null,
          "params": {
            "red": 1,
            "green": 1,
            "blue": 1,
            "red2": 1,
            "green2": 1,
            "blue2": 1,
            "red3": 1,
            "green3": 1,
            "blue3": 1,
            "speed": 1,
            "param1": 0.5,
            "param2": 0.5
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Stage Lighting Simulator\n// A Three.js scene demonstrating concert/stage lighting effects\n//\n// @param cameraSpeed float 0.002 [0, 0.01] \"Camera rotation speed\"\n// @param movingHeadSpeed float 0.5 [0.1, 2.0] \"Moving head animation speed\"\n// @param ledBarSpeed float 0.3 [0.1, 1.0] \"LED bar color cycle speed\"\n// @param hazeOpacity float 0.4 [0, 1] \"Haze particle opacity\"\n// @param blinderFlashRate float 2.0 [0.5, 5.0] \"Blinder flash rate\"\n// @param spotIntensity float 50 [10, 100] \"Spot light intensity\"\n// @param movingHeadIntensity float 80 [20, 150] \"Moving head intensity\"\n// @param autoRotate int 1 [0, 1] \"Camera auto-rotation\"\n// @param cameraView float 60.0 [1.0,360] \"Camera View\"\n\nfunction setup(THREE, canvas, params, channels, mouse) {\n  // Scene setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x050508);\n  scene.fog = new THREE.FogExp2(0x050508, 0.015);\n\n  const camera = new THREE.PerspectiveCamera(params.cameraView, canvas.width / canvas.height, 0.1, 1000);\n  camera.position.set(0, 8, 25);\n  camera.lookAt(0, 3, 0);\n\n  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });\n  renderer.setSize(canvas.width, canvas.height, false);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n  // Ambient light (very dim)\n  const ambient = new THREE.AmbientLight(0x111122, 0.3);\n  scene.add(ambient);\n\n  // Stage floor\n  const stageGeo = new THREE.BoxGeometry(30, 0.5, 20);\n  const stageMat = new THREE.MeshStandardMaterial({\n    color: 0x1a1a1a,\n    roughness: 0.8,\n    metalness: 0.2\n  });\n  const stage = new THREE.Mesh(stageGeo, stageMat);\n  stage.position.y = -0.25;\n  stage.receiveShadow = true;\n  scene.add(stage);\n\n  // Back wall\n  const wallGeo = new THREE.BoxGeometry(30, 15, 0.5);\n  const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9 });\n  const backWall = new THREE.Mesh(wallGeo, wallMat);\n  backWall.position.set(0, 7, -10);\n  backWall.receiveShadow = true;\n  scene.add(backWall);\n\n  // Truss system\n  const trussMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 });\n\n  function createTruss(length) {\n    const group = new THREE.Group();\n    const radius = 0.08;\n\n    const positions = [[-0.3, 0.3], [0.3, 0.3], [-0.3, -0.3], [0.3, -0.3]];\n\n    positions.forEach(([y, z]) => {\n      const geo = new THREE.CylinderGeometry(radius, radius, length, 8);\n      geo.rotateZ(Math.PI / 2);\n      const mesh = new THREE.Mesh(geo, trussMat);\n      mesh.position.set(0, y, z);\n      group.add(mesh);\n    });\n\n    const braceCount = Math.floor(length / 2);\n    for (let i = 0; i <= braceCount; i++) {\n      const x = -length/2 + i * (length / braceCount);\n      const ringGeo = new THREE.TorusGeometry(0.35, 0.04, 8, 4);\n      ringGeo.rotateY(Math.PI / 2);\n      const ring = new THREE.Mesh(ringGeo, trussMat);\n      ring.position.x = x;\n      group.add(ring);\n    }\n\n    return group;\n  }\n\n  // Trusses\n  const frontTruss = createTruss(28);\n  frontTruss.position.set(0, 10, 5);\n  scene.add(frontTruss);\n\n  const backTruss = createTruss(28);\n  backTruss.position.set(0, 12, -5);\n  scene.add(backTruss);\n\n  const leftTruss = createTruss(12);\n  leftTruss.rotation.y = Math.PI / 2;\n  leftTruss.position.set(-14, 10, 0);\n  scene.add(leftTruss);\n\n  const rightTruss = createTruss(12);\n  rightTruss.rotation.y = Math.PI / 2;\n  rightTruss.position.set(14, 10, 0);\n  scene.add(rightTruss);\n\n  // Arrays to store animated lights\n  const movingHeads = [];\n  const spotLights = [];\n  const barLights = [];\n\n  // Helper to create volumetric cone\n  function createLightCone(color, angle = 0.4, length = 12) {\n    const coneGeo = new THREE.ConeGeometry(Math.tan(angle) * length, length, 32, 1, true);\n    const coneMat = new THREE.MeshBasicMaterial({\n      color: color,\n      transparent: true,\n      opacity: 0.08,\n      side: THREE.DoubleSide,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false\n    });\n    const cone = new THREE.Mesh(coneGeo, coneMat);\n    cone.rotation.x = Math.PI;\n    cone.position.y = -length / 2;\n    return cone;\n  }\n\n  // Create fixture housing\n  function createFixtureHousing(type = 'spot') {\n    const group = new THREE.Group();\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.7, roughness: 0.3 });\n\n    if (type === 'moving') {\n      const yokeGeo = new THREE.BoxGeometry(0.6, 0.8, 0.15);\n      const yoke = new THREE.Mesh(yokeGeo, housingMat);\n      group.add(yoke);\n\n      const headGroup = new THREE.Group();\n      const headGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.7, 16);\n      headGeo.rotateX(Math.PI / 2);\n      const head = new THREE.Mesh(headGeo, housingMat);\n      headGroup.add(head);\n\n      const lensGeo = new THREE.CircleGeometry(0.3, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.position.z = 0.36;\n      headGroup.add(lens);\n\n      headGroup.position.y = -0.4;\n      group.add(headGroup);\n      group.headGroup = headGroup;\n      group.lens = lens;\n    } else if (type === 'spot') {\n      const bodyGeo = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI;\n      group.add(body);\n\n      const lensGeo = new THREE.CircleGeometry(0.33, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.rotation.x = Math.PI / 2;\n      lens.position.y = -0.41;\n      group.add(lens);\n    } else if (type === 'par') {\n      const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI / 2;\n      group.add(body);\n    }\n\n    return group;\n  }\n\n  // SPOT LIGHTS - Front truss\n  const spotColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];\n  for (let i = 0; i < 6; i++) {\n    const x = -12 + i * 4.8;\n    const color = spotColors[i];\n\n    const fixture = createFixtureHousing('spot');\n    fixture.position.set(x, 9.5, 5);\n    fixture.rotation.x = 0.3;\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.spotIntensity, 25, 0.4, 0.5, 1);\n    spot.position.set(x, 9.2, 5);\n    spot.target.position.set(x * 0.3, 0, -2);\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.4, 10);\n    cone.position.set(x, 9.2, 5);\n    cone.rotation.x = 0.3;\n    scene.add(cone);\n\n    spotLights.push({ light: spot, cone, fixture, baseX: x, color });\n  }\n\n  // MOVING HEADS - Back truss\n  const movingColors = [0xff0066, 0x00ffff, 0xff6600, 0x00ff66, 0x6600ff, 0xffff00];\n  for (let i = 0; i < 6; i++) {\n    const x = -10 + i * 4;\n    const color = movingColors[i];\n\n    const fixture = createFixtureHousing('moving');\n    fixture.position.set(x, 11.5, -5);\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.movingHeadIntensity, 30, 0.25, 0.3, 1);\n    spot.position.set(x, 10.8, -5);\n    spot.castShadow = true;\n    spot.shadow.mapSize.width = 512;\n    spot.shadow.mapSize.height = 512;\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.25, 14);\n    scene.add(cone);\n\n    movingHeads.push({\n      light: spot,\n      cone,\n      fixture,\n      baseX: x,\n      phase: i * Math.PI / 3,\n      color\n    });\n  }\n\n  // LED BARS\n  function createLEDBar(width, segments) {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(width, 0.15, 0.2);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const segmentWidth = width / segments;\n    const lights = [];\n\n    for (let i = 0; i < segments; i++) {\n      const x = -width/2 + segmentWidth/2 + i * segmentWidth;\n      const ledGeo = new THREE.PlaneGeometry(segmentWidth * 0.8, 0.1);\n      const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });\n      const led = new THREE.Mesh(ledGeo, ledMat);\n      led.position.set(x, 0.08, 0);\n      led.rotation.x = -Math.PI / 2;\n      group.add(led);\n\n      const pointLight = new THREE.PointLight(0xffffff, 2, 4);\n      pointLight.position.set(x, 0.2, 0);\n      group.add(pointLight);\n\n      lights.push({ mesh: led, light: pointLight, index: i });\n    }\n\n    group.lights = lights;\n    return group;\n  }\n\n  const frontBar1 = createLEDBar(8, 12);\n  frontBar1.position.set(-8, 0.1, 8);\n  frontBar1.rotation.x = -0.2;\n  scene.add(frontBar1);\n  barLights.push({ bar: frontBar1, phase: 0 });\n\n  const frontBar2 = createLEDBar(8, 12);\n  frontBar2.position.set(8, 0.1, 8);\n  frontBar2.rotation.x = -0.2;\n  scene.add(frontBar2);\n  barLights.push({ bar: frontBar2, phase: Math.PI });\n\n  const backBar = createLEDBar(20, 24);\n  backBar.position.set(0, 0.1, -8);\n  backBar.rotation.x = 0.8;\n  scene.add(backBar);\n  barLights.push({ bar: backBar, phase: 0, isBack: true });\n\n  // WASH LIGHTS\n  const washColors = [0xff3366, 0x3366ff, 0xff3366, 0x3366ff];\n  const washPositions = [[-14, 10, 4], [-14, 10, -4], [14, 10, 4], [14, 10, -4]];\n\n  washPositions.forEach((pos, i) => {\n    const color = washColors[i];\n    const wash = new THREE.SpotLight(color, 40, 25, 0.8, 0.8, 1);\n    wash.position.set(...pos);\n    wash.target.position.set(0, 0, pos[2] * 0.5);\n    scene.add(wash);\n    scene.add(wash.target);\n\n    const cone = createLightCone(color, 0.8, 12);\n    cone.position.set(...pos);\n    cone.rotation.z = i < 2 ? 0.5 : -0.5;\n    scene.add(cone);\n  });\n\n  // BLINDERS\n  function createBlinder() {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(2, 0.8, 0.4);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const cells = [];\n    for (let i = 0; i < 4; i++) {\n      const x = -0.75 + i * 0.5;\n      const cellGeo = new THREE.CircleGeometry(0.18, 16);\n      const cellMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const cell = new THREE.Mesh(cellGeo, cellMat);\n      cell.position.set(x, 0, 0.21);\n      group.add(cell);\n\n      const light = new THREE.SpotLight(0xffffcc, 0, 15, 0.6, 0.5, 1);\n      light.position.set(x, 0, 0.3);\n      light.target.position.set(x, -5, 10);\n      group.add(light);\n      group.add(light.target);\n\n      cells.push({ mesh: cell, light });\n    }\n\n    group.cells = cells;\n    return group;\n  }\n\n  const blinder = createBlinder();\n  blinder.position.set(0, 9.5, 5.3);\n  blinder.rotation.x = 0.4;\n  scene.add(blinder);\n\n  // Haze particles\n  const hazeGeo = new THREE.BufferGeometry();\n  const hazeCount = 2000;\n  const hazePositions = new Float32Array(hazeCount * 3);\n\n  for (let i = 0; i < hazeCount; i++) {\n    hazePositions[i * 3] = (Math.random() - 0.5) * 30;\n    hazePositions[i * 3 + 1] = Math.random() * 15;\n    hazePositions[i * 3 + 2] = (Math.random() - 0.5) * 25;\n  }\n\n  hazeGeo.setAttribute('position', new THREE.BufferAttribute(hazePositions, 3));\n  const hazeMat = new THREE.PointsMaterial({\n    color: 0x666688,\n    size: 0.08,\n    transparent: true,\n    opacity: params.hazeOpacity,\n    blending: THREE.AdditiveBlending\n  });\n  const haze = new THREE.Points(hazeGeo, hazeMat);\n  scene.add(haze);\n\n  return {\n    scene,\n    camera,\n    renderer,\n    objects: {\n      movingHeads,\n      spotLights,\n      barLights,\n      blinder,\n      haze,\n      hazeMat,\n      hazeCount,\n      cameraAngle: 0\n    }\n  };\n}\n\nfunction animate(time, delta, params, objects, mouse, channels) {\n  const { movingHeads, spotLights, barLights, blinder, haze, hazeMat, hazeCount } = objects;\n  const THREE = window.THREE;\n\n  // Update haze opacity from params\n  hazeMat.opacity = params.hazeOpacity;\n\n  // Animate moving heads\n  movingHeads.forEach((mh, i) => {\n    const speed = params.movingHeadSpeed;\n    const pan = Math.sin(time * speed + mh.phase) * 0.8;\n    const tilt = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 0.3 + 0.5;\n\n    if (mh.fixture.headGroup) {\n      mh.fixture.headGroup.rotation.x = tilt;\n      mh.fixture.rotation.y = pan;\n    }\n\n    const targetX = mh.baseX + Math.sin(time * speed + mh.phase) * 8;\n    const targetZ = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 5;\n    mh.light.target.position.set(targetX, 0, targetZ);\n\n    mh.cone.position.copy(mh.light.position);\n    const dir = new THREE.Vector3().subVectors(mh.light.target.position, mh.light.position).normalize();\n    mh.cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir);\n\n    // Color cycling\n    const hue = (time * 0.1 + i * 0.1) % 1;\n    const color = new THREE.Color().setHSL(hue, 1, 0.5);\n    mh.light.color = color;\n    mh.light.intensity = params.movingHeadIntensity;\n    mh.cone.material.color = color;\n    if (mh.fixture.lens) mh.fixture.lens.material.color = color;\n  });\n\n  // Animate LED bars\n  const ledSpeed = params.ledBarSpeed;\n  barLights.forEach((bl) => {\n    bl.bar.lights.forEach((led, i) => {\n      const hue = (time * ledSpeed + i * 0.05 + bl.phase) % 1;\n      const brightness = (Math.sin(time * 3 + i * 0.3 + bl.phase) + 1) / 2;\n      const color = new THREE.Color().setHSL(hue, 1, 0.5 * brightness + 0.2);\n      led.mesh.material.color = color;\n      led.light.color = color;\n      led.light.intensity = brightness * 3;\n    });\n  });\n\n  // Blinder flash effect\n  const blinderOn = Math.sin(time * params.blinderFlashRate) > 0.9;\n  blinder.cells.forEach((cell) => {\n    cell.light.intensity = blinderOn ? 100 : 0;\n    cell.mesh.material.color.setHex(blinderOn ? 0xffffff : 0x333322);\n  });\n\n  // Animate spot light intensity\n  spotLights.forEach((sl, i) => {\n    const pulse = (Math.sin(time * 2 + i * 0.5) + 1) / 2;\n    sl.light.intensity = params.spotIntensity * (0.6 + pulse * 0.4);\n    sl.cone.material.opacity = 0.05 + pulse * 0.05;\n  });\n\n  // Haze drift\n  const positions = haze.geometry.attributes.position.array;\n  for (let i = 0; i < hazeCount; i++) {\n    positions[i * 3 + 1] += 0.005;\n    if (positions[i * 3 + 1] > 15) positions[i * 3 + 1] = 0;\n  }\n  haze.geometry.attributes.position.needsUpdate = true;\n\n  // Camera auto-rotation\n  if (params.autoRotate === 1) {\n    objects.cameraAngle += params.cameraSpeed;\n  }\n}\n\nfunction cleanup(objects) {\n  if (objects.haze) {\n    objects.haze.geometry.dispose();\n    objects.hazeMat.dispose();\n  }\n}\n",
          "filePath": null,
          "params": {
            "speed": 1,
            "showGround": 0.5,
            "lightHeight": 0.5,
            "lightDepth": 0.5,
            "light1": [
              1,
              1,
              1
            ],
            "light2": [
              1,
              1,
              1
            ],
            "light3": [
              1,
              1,
              1
            ],
            "light4": [
              1,
              1,
              1
            ],
            "light5": [
              1,
              1,
              1
            ],
            "light6": [
              1,
              1,
              1
            ],
            "light7": [
              1,
              1,
              1
            ],
            "light8": [
              1,
              1,
              1
            ]
          },
          "customParams": {},
          "presets": [
            {
              "params": {
                "speed": 1,
                "showGround": 0.32,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  0.30980392156862746,
                  0.9803921568627451,
                  0.0196078431372549
                ],
                "light2": [
                  1,
                  0,
                  0
                ],
                "light3": [
                  0,
                  0,
                  1
                ],
                "light4": [
                  1,
                  0,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  0
                ],
                "light7": [
                  0,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  1,
                  1,
                  1
                ],
                "light2": [
                  0,
                  1,
                  1
                ],
                "light3": [
                  1,
                  1,
                  1
                ],
                "light4": [
                  1,
                  0,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  1
                ],
                "light7": [
                  1,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  0
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  1,
                  1,
                  1
                ],
                "light2": [
                  1,
                  1,
                  1
                ],
                "light3": [
                  1,
                  1,
                  1
                ],
                "light4": [
                  1,
                  1,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  1
                ],
                "light7": [
                  1,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "name": null
            }
          ],
          "type": "scene"
        },
        {
          "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @texture iChannel0 RGBANoise\n// @param iFlame float 0.3 [0.0,5.0] \"Flamme\"\n// @param light1 color [0.9, 0.4, 0.1] \"Flame 1\"\n// @param light2 color [0.2, 0.6, 0.8] \"Flame 2\"\n// @param light3 color [0.9, 0.0, 1.0] \"Flame 3\"\n// @param light4 color [0.2, 0.3, 0.8] \"Flame 4\"\n// @param light5 color [0.9, 0.4, 0.6] \"Flame 5\"\n// @param light6 color [0.2, 0.6, 0.7] \"Flame 6\"\n// @param light7 color [0.9, 0.4, 0.3] \"Flame 7\"\n// @param light8 color [0.2, 0.3, 0.8] \"Flame 8\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*.03*iFlame, s - iTime*.1*iFlame)).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - .4);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 f1 = flame(u+vec2( 7.5,0.2),.1,light1,vec3(.9,.7,.3));\n    vec3 f2 = flame(u+vec2( 6.,0.),.2,light2,vec3(.6,.8,.9));\n    vec3 f3 = flame(u+vec2( 4.5,0.),.3,light3,vec3(.9,.3,.0));\n    vec3 f4 = flame(u+vec2( 3.,0.),.4,light4,vec3(.9,.6,.9));\n    vec3 f5 = flame(u+vec2( 1.5,0.),.5,light5,vec3(.9,.7,.3));\n    vec3 f6 = flame(u+vec2( 0.,0.),.6,light6,vec3(.6,.8,.9));\n    vec3 f7 = flame(u+vec2( -1.5,0.),.7,light7,vec3(1.,.8,.5));\n    vec3 f8 = flame(u+vec2(-3.,0.),.8,light8,vec3(.9,.6,.9));\n\n    vec3 C = f1+f2+f3+f4+f5+f6+f7+f8;\n    O = vec4(C+C,1.0);\n    \n}",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "iFlame": 0.64,
            "light1": [
              0.2,
              0.30196078431372547,
              0.8
            ],
            "light2": [
              0.2,
              0.6,
              0.8
            ],
            "light3": [
              0.9019607843137255,
              0.4,
              0.30196078431372547
            ],
            "light4": [
              1,
              0.54,
              0.23
            ],
            "light5": [
              0.9,
              0.4,
              0.3
            ],
            "light6": [
              0.2,
              0.3,
              0.8
            ],
            "light7": [
              0.9,
              0,
              1
            ],
            "light8": [
              0.2,
              0.3,
              0.8
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Custom params: // @param name type [default] [min, max] \"description\"\n\n/*\n\n    Bumped Sinusoidal Warp\n    ----------------------\n\n    Sinusoidal planar deformation, or the 2D sine warp effect to people \n    like me. The effect has been around for years, and there are\n    countless examples on the net. IQ's \"Sculpture III\" is basically a \n    much more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n    turn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n    the frequency and iteration count in order to make it less busy.\n\n    I also threw in a texture, added point-lit bump mapping, speckles... \n    and that's pretty much it. As for why a metallic surface would be \n    defying\tthe laws of physics and moving like this is anyone's guess. :)\n\n    By the way, I have a 3D version, similar to this, that I'll put up at \n    a later date.\n    \n\n\n    Related examples:\n\n    Fantomas - Plop\n    https://www.shadertoy.com/view/ltSSDV\n\n    Fabrice - Plop 2\n    https://www.shadertoy.com/view/MlSSDV\n\n    IQ - Sculpture III (loosely related)\n    https://www.shadertoy.com/view/XtjSDK\n\n    Shane - Lit Sine Warp (far less code)\n    https://www.shadertoy.com/view/Ml2XDV\n\n*/\n\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p + 3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos(p.yx*3. + vec2(t, 1.57))/3.;\n        p += sin(p.yx + t + vec2(1.57, 0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p += fract(sin(p+vec2(13, 7))*5e5)*.03 - .015;\n\n    return mod(p, 2.) - 1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, \n// we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n    return length(W(p))*.7071; // Range: [0, 1]\n\n}\n\n/*\n// Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*/\n\nvec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //float th = sin(iTime*0.1)*sin(iTime*0.12)*2.;\n    //float cs = cos(th), si = sin(th);\n    //uv *= mat2(cs, -si, si, cs);\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a \n    // bump mapped plane situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion, or hit point. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.2, -1); // Light position - Back from the screen.\n    vec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n \n     \n/*\n    // I deliberately left this block in to show that the above is a simplified version\n    // of a raytraced plane. The \"rayPlane\" equation is commented out above.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0, 0, -1);\n\n    // Plane normal.\n    vec3 sn = normalize(vec3(cos(iTime)*.25, sin(iTime)*.25, -1));\n    //vec3 sn = normalize(vec3(0, 0, -1));\n    \n    vec3 sp = rayPlane(vec3(0), ro, sn, rd);\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.25, -1); \n*/    \n    \n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n   \n    // Controls how much the bump is accentuated.\n    const float bumpFactor = .05;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize(sn + grad*bumpFactor ); \n    sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);   \n    // Equivalent to the following.\n    //sn = cross(-vec3(1, 0, fx*bumpFactor), vec3(0, 1, fy*bumpFactor));\n    //sn = normalize(sn);\n   \n    \n    // LIGHTING\n    //\n    // Determine the light direction vector, calculate its distance, then normalize it.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*.15);\n    //float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n    \n\n    // Diffuse value.\n    float diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n    //float spec = pow(max(dot(normalize(ld - rd), sn), 0.), 32.);\n    \n    \n    // TEXTURE COLOR\n    //\n    // Combining the surface postion with a fraction of the warped surface position to index \n    // into the texture. The result is a slightly warped texture, as a opposed to a completely \n    // warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    // so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    // it's more readable this way.\n    vec3 texCol = texture(iChannel0, sp.xy + W(sp.xy)/8.).xyz; \n    texCol *= texCol; // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    // A bit of color processing.\n    texCol = smoothstep(.05, .75, pow(texCol, vec3(.75, .8, .85)));    \n    \n    // Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    //vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .2;\n    \n    \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*vec3(1, .97, .92)*2. + .5) + vec3(1, .6, .2)*spec*2.)*atten;\n    \n    // Faux environment mapping: I added this in at a later date out of sheer boredome, and  \n    // because I like shiny stuff. You can comment it out if it's not to your liking. :)\n    float ref = max(dot(reflect(rd, sn), vec3(1)), 0.);\n    col += col*pow(ref, 4.)*vec3(.25, .5, 1)*3.;\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/shadertoy/fluessig1.frag",
          "params": {
            "speed": 1.22,
            "p0": 0.05,
            "p1": 0.49,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 0,
            "g0": 0,
            "b0": 0,
            "r1": 0,
            "g1": 0,
            "b1": 0,
            "r2": 0,
            "g2": 0,
            "b2": 0,
            "r3": 0,
            "g3": 0,
            "b3": 0,
            "r4": 0,
            "g4": 0,
            "b4": 0,
            "r5": 0,
            "g5": 0,
            "b5": 0,
            "r6": 0,
            "g6": 0,
            "b6": 0,
            "r7": 0,
            "g7": 0,
            "b7": 0,
            "r8": 0,
            "g8": 0,
            "b8": 0,
            "r9": 0,
            "g9": 0,
            "b9": 0
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @texture iChannel0 RGBANoise\n// @param light1 color[2] [[0.9, 0.4, 0.1],[0.9,0.7,0.3]] \"Flamme 1\"\n// @param light2 color[2] [[0.2, 0.6, 0.7],[0.6,0.8,0.9]] \"Flamme 2\"\n// @param light3 color[2] [[0.9, 0.3, 0.0],[0.9,0.3,0.0]] \"Flamme 3\"\n// @param light4 color[2] [[0.2, 0.3, 0.8],[0.9,0.6,0.9]] \"Flamme 4\"\n// @param light5 color[2] [[0.9, 0.4, 0.6],[0.9,0.7,0.3]] \"Flamme 5\"\n// @param light6 color[2] [[0.2, 0.6, 0.0],[0.6,0.8,0.9]] \"Flamme 6\"\n// @param light7 color[2] [[0.9, 0.4, 0.7],[0.1,0.8,0.5]] \"Flamme 7\"\n// @param light8 color[2] [[0.2, 0.3, 0.3],[0.9,0.6,0.9]] \"Flamme 8\"\n// @param fspeed vec2 [0.03, 0.1] [0.0,1.0] \"Flamme 8\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*fspeed[0], s - iTime*fspeed[1])).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - .4);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 f1 = flame(u+vec2( 7.5,0.0),.1,light1[0],light1[1]);\n    vec3 f2 = flame(u+vec2( 6.,0.),.2,light2[0],light2[1]);\n    vec3 f3 = flame(u+vec2( 4.5,0.),.3,light3[0],light3[1]);\n    vec3 f4 = flame(u+vec2( 3.,0.),.4,light4[0],light4[1]);\n    vec3 f5 = flame(u+vec2( 1.5,0.),.5,light5[0],light5[1]);\n    vec3 f6 = flame(u+vec2( 0.,0.),.6,light6[0],light6[1]);\n    vec3 f7 = flame(u+vec2( -1.5,0.),.7,light7[0],light7[1]);\n    vec3 f8 = flame(u+vec2(-3.,0.),.8,light8[0],light8[1]);\n\n    vec3 C = f1+f2+f3+f4+f5+f6+f7+f8;\n    O = vec4(C+C,1.0);\n}",
          "filePath": null,
          "params": {
            "speed": 1.16
          },
          "customParams": {
            "light1": [
              [
                0.9,
                0.4,
                0.1
              ],
              [
                0.9,
                0.7,
                0.3
              ]
            ],
            "light2": [
              [
                0.2,
                0.6,
                0.7
              ],
              [
                0.6,
                0.8,
                0.9
              ]
            ],
            "light3": [
              [
                0.9,
                0.3,
                0
              ],
              [
                0.9,
                0.3,
                0
              ]
            ],
            "light4": [
              [
                0.2,
                0.3,
                0.8
              ],
              [
                0.9,
                0.6,
                0.9
              ]
            ],
            "light5": [
              [
                0.9,
                0.4,
                0.6
              ],
              [
                0.9,
                0.7,
                0.3
              ]
            ],
            "light6": [
              [
                0.2,
                0.6,
                0
              ],
              [
                0.6,
                0.8,
                0.9
              ]
            ],
            "light7": [
              [
                0.9,
                0.4,
                0.7
              ],
              [
                0.1,
                0.8,
                0.5
              ]
            ],
            "light8": [
              [
                0.2,
                0.3,
                0.3
              ],
              [
                0.9,
                0.6,
                0.9
              ]
            ],
            "fspeed": [
              0.05,
              0.1
            ],
            "size": [
              0.4,
              0.58
            ],
            "pos": [
              0,
              0.1
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    \n    float pi = 3.1415926535897; \n\n     \n    float cx = uv.x+0.5*sin(iTime/5.0); \n    float cy = uv.y+0.5*cos(iTime/3.0); \n     \n    float v = sin(sqrt(100.0*(cx*cx+cy*cy))); \n    v += sin(uv.x*10.0+iTime); \n    v += cos(uv.y*4.0+iTime); \n     \n    fragColor = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0); \n    \n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {
            "roomColor": [
              0.4588235294117647,
              0.4,
              0
            ],
            "center": [
              0.5,
              0.5
            ]
          },
          "presets": [
            {
              "params": {
                "speed": 1,
                "roomColor": [
                  0.4588235294117647,
                  0.4,
                  0
                ],
                "center": [
                  0.5,
                  0.5
                ]
              },
              "name": null
            }
          ],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\n\nvec3 palette(float d){\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.89);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n/*\n    \"Artifacts\" by @XorDev\n    \n    https://x.com/XorDev/status/2008361514684539306\n*/\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Iterator, raymarch depth and step distance\n    float i, z, d;\n    \n    //Raymarch sample point\n    vec3 p;\n    \n    //Clear fragColor and raymarch 77 steps\n    for(O*=i; i++<77.;\n        //Slowly step forward using the distance to a distorted z-plane\n        z += d = abs(p.z/30.+.2),\n        //Add color (attenuating with distance to surface)\n        O += vec4(z,z,9,1) / d,\n        //Compute the next sample point\n        p = z * normalize(vec3(I+I,0) - iResolution.xyy),\n        //Shift diagonally\n        p.xy += iTime)\n        \n        //Use blocky \"turbulence\" for the distortion\n        //https://mini.gmshaders.com/p/turbulence\n        for(d=0.; d++<9.; p+=sin(round(p)+d*3.).zxy);\n        \n    //Tanh tonemapping\n    //https://mini.gmshaders.com/p/func-tanh\n    O = tanh(O/8e4);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n// genuary: Lights on/off. Make something that changes when you switch on or off the digital lights.\n\n// flight path, given z, get xy\n#define P(z) vec3(cos((z)*.01)*164.,cos((z)*.012)*164., z)\n\n// MENGERLAYER\n#define m(f, h)\\\n    s /= (f), \\\n    p = abs(fract(q/s)*s - s*.5), \\\n \td = min(d, min(max(p.x, p.y), \\\n               min(max(p.y, p.z), \\\n               max(p.x, p.z))) - s/(h))\n\nvoid mainImage(out vec4 o, vec2 u) {\n   \n    float i, T = iTime,d,s = 1.275,\n          j = (.05*dot(fract(sin(.7*T+u)), sin(u))),\n          f;\n    vec3  c,r = iResolution;\n    mat2 rot = mat2(cos(cos(T*.06)*4.+vec4(0,33,11,0)));\n    \n    // scale coords\n    u = (u+u - r.xy) / r.y;\n\n    // cinema bars\n    if (abs(u.y) > .75) { o = vec4(0); return; }\n    \n    // look around\n    u += vec2( sin(iTime)*.5, sin(iTime*.5)*.5 );\n    \n    // on-off frequency, changes color, too\n    f = (1.+tanh(cos(sin(T*T)*.05+T*.3)*3.)*13.);\n    \n    // set up ray origin, dir, look-at\n    vec3  q,p = P(T*32.),\n          Z = normalize( P(T*32.+4.) - p),\n          X = normalize(vec3(Z.z,0,-Z)),\n          D = vec3(rot*u, 1) * mat3(-X, cross(X, Z), Z);\n \n    for(;i++ < 64.;\n        // add grayscale color and foggy border\n        c += s + .4*dot(u,u) - f/s\n    )\n        // raymarch position\n        q = p += j + D * s,\n        // can play with initial dist (d) and scale (s)\n        d=9e9,s=2e2,\n\n        // apply some menger layers\n        m(1., 3.),\n        m(2., 4.),\n        m(9., 4.),\n        p += cos(p.yzx) * 1e1,\n        // -1 to 1 + min(gyroid, menger);\n        s = .02+.5*abs(sin(p.z*.2)+min(dot(sin(q/236.), cos(q.yzx/166.))*5., d)),\n        // restore p (m() macro modifies it)\n        p = q;\n    \n    \n    // tanh tone map, colorize, divide brightness\n    o.rgb = tanh(vec3(f,2,3)*c/1e4);\n\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n#define A 9. // amplitude\n#define T (iTime/3e2)\n#define H(a) (cos(radians(vec3(180, 90, 0))+(a)*6.2832)*.5+.5)  // hue\n\nfloat map(vec3 u, float v)  // sdf\n{\n    float t = T,     // speed\n          l = 5.,    // loop to reduce clipping\n          f = 1e10, i = 0., y, z;\n    \n    u.xy = vec2(atan(u.x, u.y), length(u.xy));  // polar transform\n    u.x += t*v*3.1416*.7;  // counter rotation\n    \n    for (; i++<l;)\n    {\n        vec3 p = u;\n        y = round((p.y-i)/l)*l+i;\n        p.x *= y;\n        p.x -= y*y*t*3.1416;\n        p.x -= round(p.x/6.2832)*6.2832;\n        p.y -= y;\n        z = cos(y*t*6.2832)*.5 +.5;  // z wave\n        f = min(f, max(length(p.xy), -p.z -z*A) -.1 -z*.2 -p.z/1e2);  // tubes\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec2 R = iResolution.xy, j,\n         M = iMouse.xy,\n         m = (M -R/2.)/R.y;\n    \n    if (iMouse.z < 1. && M.x+M.y < 10.) m = vec2(0, .5);\n    \n    vec3 o = vec3(0, 0, -130.),  // camera\n         u = normalize(vec3(U -R/2., R.y)),  // 3d coords\n         c = vec3(0),\n         p, k;\n    \n    float t = T,\n          v = -o.z/3.,  // pattern scale\n          i = 0., d = i,\n          s, f, z, r;\n    \n    bool b;\n    \n    for (; i++<70.;)  // raymarch\n    {\n        p = u*d +o;\n        p.xy /= v;           // scale down\n        r = length(p.xy);    // radius\n        z = abs(1. -r*r);    // z warp\n        b = r < 1.;          // inside?\n        if (b) z = sqrt(z);\n        p.xy /= z+1.;        // spherize\n        p.xy -= m;           // move with mouse\n        p.xy *= v;           // scale back up\n        p.xy -= cos(p.z/8. +t*3e2 +vec2(0, 1.5708) +z/2.)*.2;  // wave along z\n        \n        s = map(p, v);  // sdf\n        \n        r = length(p.xy);                  // new r\n        f = cos(round(r)*t*6.2832)*.5+.5;  // multiples\n        k = H(.2 -f/3. +t +p.z/2e2);       // color\n        if (b) k = 1.-k;                   // flip color\n        \n        // this stuff can go outside the raymarch,\n        // but accumulating it here produces softer edges\n        c += min(exp(s/-.05), s)        // shapes\n           * (f+.01)                    // shade pattern\n           * min(z, 1.)                 // darken edges\n           * sqrt(cos(r*6.2832)*.5 +.5) // shade between rows\n           * k*k;                       // color\n        \n        d += s*clamp(z, .3, .9);  // smaller steps towards sphere edge\n        if (s < 1e-3 || d > 1e3) break;\n    }\n    \n    // c += texture(iChannel0, u*d +o).rrr * vec3(0, .4, s)*s*z*.03;  // wavy aqua\n    c += min(exp(-p.z -f*A)*z*k*.01/s, 1.);  // light tips\n        \n    j = p.xy/v +m;  // 2d coords\n    c /= clamp(dot(j, j)*4., .04, 4.);  // brightness\n    \n    C = vec4(exp(log(c)/2.2), 1);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "\n// @param cColor color[10] [[1.0, 0.0, 0.0],[0.0, 1.0, 0.0],[0.0, 0.0, 1.0],[1.0, 1.0, 0.1],[0.0, 0.5, 1.0],[1.0, 0.5, 0.0],[0.0, 1.0, 0.5],[1.0, 0.0, 1.0],[1.0, 1.0, 1.0],[0.5, 0.0, 1.0]] \"Fire color\"\n// @param colors vec2 [3.0,3.0] [1,10]\n// @param rradius float 0.5 [0.0, 1.0] \"radius halo\"\n// @param mradius float 0.1 [0.0, 1.0] \"Radius voll\"\n// @param gridsize int 10 [0,100] \"Anzahl\"\n// @param xspeed vec2 [0.0,0.0] [-2.0,2.0] \"Geschwindigkeit\"\n// @param cspeed vec2 [0.0,0.0] [-2.0,2.0] \"Geschwindigkeit\"\n// @param pos vec2 [0.0,0.0] [-2.0,2.0] \"Geschwindigkeit\"\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to 0-1 range\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 t = vec2(mod(iTime, iResolution.x), mod(iTime, iResolution.y));\n    \n    uv = uv + (t * xspeed) + pos;\n\n    // Grid parameters\n    float gridSize = float(gridsize);\n    float radius = rradius * (1.0 / gridSize);\n    \n    // Scale UV to grid space (0 to 10)\n    vec2 gridUV = uv * gridSize;\n    \n    // Get the cell index (0-9) and position within cell (0-1)\n    vec2 cellIndex = floor(gridUV);\n    vec2 cellUV = fract(gridUV);\n    \n    // Center of each cell is at (0.5, 0.5) in cell space\n    // Convert radius to cell space (cell is 1/10 of screen, so radius * 10)\n    float cellRadius = radius * gridSize;\n    \n    // Distance from center of cell\n    float dist = distance(cellUV, vec2(0.5));\n    \n    // Draw circle: white inside, black outside\n    float circle = smoothstep(mradius, cellRadius, dist);\n    \n    // Output color\n    vec2 c = cellIndex + t * cspeed;\n    int ci = int(mod(mod(c.x,colors.x) + mod(c.y,colors.y), 10.0));\n    vec3 color = cColor[ci] - vec3(circle);\n    \n    fragColor = vec4(color, 1.0);\n}\n",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "cColor": [
              [
                1,
                0,
                0
              ],
              [
                0,
                1,
                0
              ],
              [
                0,
                0,
                1
              ],
              [
                1,
                1,
                0.1
              ],
              [
                1,
                0,
                0
              ],
              [
                1,
                0.5,
                0
              ],
              [
                0,
                1,
                0.5
              ],
              [
                1,
                0,
                1
              ],
              [
                1,
                1,
                1
              ],
              [
                0.5,
                0,
                1
              ]
            ],
            "colors": [
              3.64,
              3
            ],
            "rradius": 0.5,
            "mradius": 0.1,
            "gridsize": 10,
            "xspeed": [
              0.7,
              -0.43
            ],
            "cspeed": [
              0.54,
              0
            ],
            "pos": [
              0,
              0
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\n\n#define P(z) vec3(cos((z)*.06)*24., cos((z)*.09)*12., z)\n#define O(Z,c) ( length(                 /* orb */   \\\n          X - vec3( sin( T*c*6. ) * 6.,        \\\n                    sin( T*c*4. ) * 2.,  \\\n                    T*4.+Z )  ) - c )\n// MENGERLAYER\n#define m(f, h)\\\n    s /= (f), \\\n    p = abs(fract(q/s)*s - s*.5), \\\n \tm = min(m, min(max(p.x, p.y), \\\n               min(max(p.y, p.z), \\\n               max(p.x, p.z))) - s/(h))\n\nvoid mainImage(out vec4 o, vec2 u) {\n   \n    float tun, i, e, T = iTime,m,d=4.,s = .5,l,\n          j = 0.;\n    vec3  c,r = iResolution;\n    mat2 rot = mat2(cos(cos(T*.2)*.6+vec4(0,33,11,0)));\n    \n    u = (u+u - r.xy) / r.y;\n\n    vec3  q,p = P(T*4.),\n          Z = normalize( P(T*4.+3.) - p),\n          X = normalize(vec3(Z.z,0,-Z)),\n          D = vec3(rot*u, 1) * mat3(-X, cross(X, Z), Z);\n \n    for(;i++ < 1e2;\n        c += (1.+cos(.6*i+vec3(2,1,0))) / s + vec3(1,2,8)*s + 1e1*vec3(5,2,1)/e\n    )\n        q = p += j + D * s,\n        X = p - P(p.z),X.z = p.z,\n        tun = 4. - length(max(abs(X.x), abs(X.y))),\n        e = max(     min( O( 5., .1),\n                     min( O( 7., .15),\n                          O( 9., .2) )), .001),\n        m=1e1,\n        s = 128.,\n        m(32., 8.),\n        s = 6.,\n        m(2., 6.),\n        m(2., 4.),\n        s = 32.,\n        m(2., 4.),\n        d += s = min(e*.5, max(tun, .001+.7*abs(m))),\n        D += s < .01 ? - .1 : 0.,\n        p = q;\n    o.rgb = tanh(c*c/7e8*exp(d/2e1));\n\n}",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/shadertoy/metal-menger.frag",
          "params": {
            "speed": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @texture iChannel0 RGBANoise\n// @param lights color[16] [[0.9, 0.4, 0.1],[0.9,0.7,0.3],[0.2, 0.6, 0.7],[0.6,0.8,0.9],[0.9, 0.3, 0.0],[0.9,0.3,0.0],[0.2, 0.3, 0.8],[0.9,0.6,0.9],[0.9, 0.4, 0.6],[0.9,0.7,0.3],[0.2, 0.6, 0.0],[0.6,0.8,0.9],[0.9, 0.4, 0.7],[0.1,0.8,0.5],[0.2, 0.3, 0.3],[0.9,0.6,0.9]]\n// @param fspeed vec2 [0.03,0.1] \"Flamme 8\"\n// @param size vec2 0.4,0.6  \"Flamme 8\"\n// @param pos vec2 0.4,0.1 [-5.0,5.0]  \"Flamme 8\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*fspeed[0]*0.2, s - iTime*fspeed[1]*.5)).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - size[0]);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 C = vec3(.0,.0,.0);\n    \n    int i = 0;\n    for(i = 0; i < 8 ; i++){\n      C +=flame(vec2(-2.0,-0.1) * pos + u+vec2(float(i) * size[1] * 2.0,0.0),.1 * float(i),lights[i*2],lights[i*2+1]);\n    }\n    \n    O = vec4(C+C,1.0);\n}",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "lights": [
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ],
              [
                0.9803921568627451,
                0,
                0
              ],
              [
                0,
                1,
                0.01568627450980392
              ]
            ],
            "fspeed": [
              0.12,
              0.14
            ],
            "size": [
              0.47,
              0.8
            ],
            "pos": [
              3.14,
              0.31
            ]
          },
          "presets": [
            {
              "params": {
                "speed": 1,
                "lights": [
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0,
                    1,
                    0.01568627450980392
                  ]
                ],
                "fspeed": [
                  0.03,
                  0.1
                ],
                "size": [
                  0.5,
                  0.72
                ],
                "pos": [
                  2.72,
                  0.93
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "lights": [
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ],
                  [
                    0.9803921568627451,
                    0,
                    0
                  ],
                  [
                    0.8627450980392157,
                    0.9254901960784314,
                    0.37254901960784315
                  ]
                ],
                "fspeed": [
                  0.03,
                  0.1
                ],
                "size": [
                  0.5,
                  0.72
                ],
                "pos": [
                  2.72,
                  0.93
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "lights": [
                  [
                    0.9,
                    0.4,
                    0.1
                  ],
                  [
                    0.9,
                    0.7,
                    0.3
                  ],
                  [
                    0.2,
                    0.6,
                    0.7
                  ],
                  [
                    0.6,
                    0.8,
                    0.9
                  ],
                  [
                    0.9,
                    0.3,
                    0
                  ],
                  [
                    0.9,
                    0.3,
                    0
                  ],
                  [
                    0.2,
                    0.3,
                    0.8
                  ],
                  [
                    0.9,
                    0.6,
                    0.9
                  ],
                  [
                    0.9,
                    0.4,
                    0.6
                  ],
                  [
                    0.9,
                    0.7,
                    0.3
                  ],
                  [
                    0.2,
                    0.6,
                    0
                  ],
                  [
                    0.6,
                    0.8,
                    0.9
                  ],
                  [
                    0.9,
                    0.4,
                    0.7
                  ],
                  [
                    0.1,
                    0.8,
                    0.5
                  ],
                  [
                    0.2,
                    0.3,
                    0.3
                  ],
                  [
                    0.9,
                    0.6,
                    0.9
                  ]
                ],
                "fspeed": [
                  0.03,
                  0.1
                ],
                "size": [
                  0.4,
                  0.6
                ],
                "pos": [
                  0.4,
                  0.1
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "lights": [
                  [
                    0.9,
                    0.4,
                    0.1
                  ],
                  [
                    0.9,
                    0.7,
                    0.3
                  ],
                  [
                    0.2,
                    0.6,
                    0.7
                  ],
                  [
                    0.6,
                    0.8,
                    0.9
                  ],
                  [
                    0.9,
                    0.3,
                    0
                  ],
                  [
                    0.9,
                    0.3,
                    0
                  ],
                  [
                    0.2,
                    0.3,
                    0.8
                  ],
                  [
                    0.9,
                    0.6,
                    0.9
                  ],
                  [
                    0.9,
                    0.4,
                    0.6
                  ],
                  [
                    0.9,
                    0.7,
                    0.3
                  ],
                  [
                    0.2,
                    0.6,
                    0
                  ],
                  [
                    0.6,
                    0.8,
                    0.9
                  ],
                  [
                    0.9,
                    0.4,
                    0.7
                  ],
                  [
                    0.1,
                    0.8,
                    0.5
                  ],
                  [
                    0.2,
                    0.3,
                    0.3
                  ],
                  [
                    0.9,
                    0.6,
                    0.9
                  ]
                ],
                "fspeed": [
                  0.03,
                  0.14
                ],
                "size": [
                  0.47,
                  0.8
                ],
                "pos": [
                  3.14,
                  0.31
                ]
              },
              "name": null
            }
          ],
          "type": "shader"
        },
        {
          "shaderCode": "// Fire shader - Parametric flame effect\n\n// @param amplification float 1.0 [0.0,5.0] \"Verstaerkung\"\n// @param iterations float 0.5 [0.0, 1.0] \"Iteration depth\"\n// @param amplitude float 0.5 [0.0, 1.0] \"Wave amplitude\"\n// @param zoom float 0.5 [0.1, 1.0] \"Zoom level\"\n// @param fireColor color [1.0, 0.3, 0.1] \"Fire color\"\n\n/*\n    @SnoopethDuckDuck -6 chars\n    @Xor              -1 chars\n\n    Thanks! :D\n\n*/\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(--r)*.1,\n        o += 1. / r)\n        for(p = vec3((u-z.xy/(2. * 2.0 * zoom))/z.y * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*(.6 + 5.0 * amplitude),\n            r =  cos(p.z),\n            e = 1.6 + iterations;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), z/z)) / e;\n    o = amplification * tanh(vec4(fireColor,1) * o * o / f / 7e6);\n}\n\n\n\n/* you can put it out with this :D\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float s=.002,i,n;\n    vec3 r = iResolution,p;\n    for(o *= i; i++ < 40. && s > .001;) {\n        s = 1. + (p += vec3((u-r.xy/2.)/r.y,1) * s).y;\n        for (n =.5; n < 20.;n+=n)\n            s += abs(dot(sin(p.z+iTime+p * n), vec3(.1))) / n;\n        o += s *.03+.03;\n    }\n    o = tanh(o);\n}\n\n*/\n\n\n/* original fire shader\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(r)*.1,\n        o += 1. / r)\n        for(p = vec3(((u-z.xy/2.)/z.y) * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*.6,\n            r =  cos(p.z)-1.,\n            e = 1.6;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), vec3(1))) / e;\n    o = tanh(vec4(6,2,1,1) * o * o / f / 7e6);\n}\n\n*/",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "amplification": 1,
            "iterations": 0.5,
            "amplitude": 0.5,
            "zoom": 0.5,
            "fireColor": [
              1,
              0.3,
              0.1
            ]
          },
          "presets": [],
          "type": "shader"
        }
      ]
    },
    {
      "name": "Special",
      "type": "shaders",
      "slots": [
        {
          "shaderCode": "// Stage Lights Array Simulation - OPTIMIZED\n// Creates an array of animated stage lights with volumetric fog\n\n// @param showGround float 0.5 [0.0, 1.0] \"Show ground (>0.5)\"\n// @param lightHeight float 0.5 [0.0, 1.0] \"Light height\"\n// @param lightDepth float 0.5 [0.0, 1.0] \"Light depth\"\n// @param light1 color [1.0, 0.0, 0.0] \"Light 1\"\n// @param light2 color [0.0, 1.0, 0.0] \"Light 2\"\n// @param light3 color [0.0, 0.0, 1.0] \"Light 3\"\n// @param light4 color [1.0, 1.0, 0.0] \"Light 4\"\n// @param light5 color [1.0, 0.0, 1.0] \"Light 5\"\n// @param light6 color [0.0, 1.0, 1.0] \"Light 6\"\n// @param light7 color [1.0, 0.5, 0.0] \"Light 7\"\n// @param light8 color [0.5, 0.0, 1.0] \"Light 8\"\n\n#define NUM_LIGHTS 8\n#define PI 3.14159265359\n#define MAX_STEPS 88  // Reduziert von ~100\n\n// Vereinfachte Noise-Funktion\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Schnellerer Noise - weniger Operationen\nfloat noise2(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    float e = hash(n + 113.0);\n    float f1 = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    return mix(mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n               mix(mix(e, f1, f.x), mix(g, h, f.x), f.y), f.z);\n}\n\nfloat noise(vec3 x){\n  return 1.0;\n}\n// Vorberechnete Lichtdaten\nstruct Light {\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    float angle;\n    float intensity;\n};\n\n// Lichtparameter einmal pro Frame berechnen\nvoid setupLights(out Light lights[NUM_LIGHTS]) {\n    // Build color array from named parameters\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = light1;\n    lightColors[1] = light2;\n    lightColors[2] = light3;\n    lightColors[3] = light4;\n    lightColors[4] = light5;\n    lightColors[5] = light6;\n    lightColors[6] = light7;\n    lightColors[7] = light8;\n\n    for (int j = 0; j < NUM_LIGHTS; j++) {\n        float lightIndex = float(j);\n        float phase = lightIndex * PI * 2.0 / float(NUM_LIGHTS);\n        float swing = sin(iTime * 0.5 + phase) * 0.3;\n        float tilt = cos(iTime * 0.7 + phase * 1.5) * 0.2;\n\n        lights[j].pos = vec3(-35.0 + lightIndex * 1.0, 3.0 * lightHeight + 3.0, 10.0 * lightDepth - 10.0);\n        lights[j].dir = normalize(vec3(swing, -0.8 + tilt, 1.0));\n        lights[j].angle = 0.3 + 0.1 * sin(iTime + phase);\n\n        // Flicker\n        float flicker = 0.9 + 0.1 * sin(iTime * 20.0 + lightIndex * 7.0);\n        lights[j].intensity = 2.0 * flicker;\n        lights[j].color = lightColors[j];\n    }\n}\n\n// Optimierte Spotlight-Berechnung\nvec3 spotlightFast(vec3 pos, Light light, float fog) {\n    vec3 toLight = light.pos - pos;\n    float dist2 = dot(toLight, toLight);  // Quadrat statt length()\n    vec3 lightVec = toLight * inversesqrt(dist2);\n    \n    float spotEffect = dot(lightVec, -light.dir);\n    float spotCutoff = cos(light.angle);\n    \n    if (spotEffect < spotCutoff) return vec3(0.0);\n    \n    float edge = smoothstep(spotCutoff, 1.0, spotEffect);\n    float dist = sqrt(dist2);\n    float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist2);\n    \n    return light.color * (edge * attenuation * fog * light.intensity);\n}\n\n// Optimiertes Ray Marching\nvec3 volumetricLighting(vec3 ro, vec3 rd, float maxDist, Light lights[NUM_LIGHTS]) {\n    vec3 color = vec3(0.0);\n    \n    // Adaptive Schrittweite\n    float stepSize = maxDist / float(MAX_STEPS);\n    stepSize = max(stepSize, 0.15);  // Minimum 0.15\n    \n    float t = stepSize * 0.5;  // Start mit halber Schrittweite (besseres Sampling)\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (t >= maxDist) break;\n        \n        vec3 pos = ro + rd * t;\n        \n        // Fog nur einmal pro Schritt berechnen\n        float fog = 0.1 + noise(pos * 0.5 + vec3(0.0, -iTime * 0.1, 0.0)) * 0.05;\n        \n        // Alle Lichter akkumulieren\n        vec3 lightContrib = vec3(0.0);\n        for (int j = 0; j < NUM_LIGHTS; j++) {\n            lightContrib += spotlightFast(pos, lights[j], fog);\n        }\n        \n        color += lightContrib;\n        t += stepSize;\n    }\n    \n    return color * stepSize;\n}\n\nfloat groundPlane(vec3 ro, vec3 rd) {\n    return rd.y < 0.0 ? -ro.y / rd.y : -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Lichter einmal pro Pixel vorberechnen\n    Light lights[NUM_LIGHTS];\n    setupLights(lights);\n    \n    // Camera\n    vec3 ro = vec3(0.0, 1.5, 5.0);\n    vec3 forward = normalize(vec3(0.0, 1.0, 0.0) - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Background\n    vec3 color = vec3(0.02, 0.02, 0.05) * (1.0 - uv.y * 0.5);\n    \n    // Ground\n    float groundT = 0.0;\n    if(showGround >= 0.5){\n    groundT = groundPlane(ro, rd);\n    if (groundT > 0.0) {\n        vec3 groundPos = ro + rd * groundT;\n        vec2 checker = floor(groundPos.xz * 2.0);\n        float pattern = mod(checker.x + checker.y, 2.0);\n        color = mix(color, mix(vec3(0.05), vec3(0.1), pattern), exp(-groundT * 0.1));\n    }\n    }\n    // Volumetric lighting\n    color += volumetricLighting(ro, rd, groundT > 0.0 ? groundT : 10.0, lights);\n    \n    // Tonemapping + Gamma + Vignette kombiniert\n    color = pow(color / (1.0 + color), vec3(0.4545)) * (1.0 - dot(uv, uv) * 0.3);\n    \n    fragColor = vec4(color, 1.0);\n} ",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {
            "showGround": 0.5,
            "lightHeight": 0.5,
            "lightDepth": 0.5,
            "light1": [
              1,
              0,
              0
            ],
            "light2": [
              0,
              1,
              0
            ],
            "light3": [
              0,
              0,
              1
            ],
            "light4": [
              1,
              1,
              0
            ],
            "light5": [
              1,
              0,
              1
            ],
            "light6": [
              0,
              1,
              1
            ],
            "light7": [
              1,
              0.5,
              0
            ],
            "light8": [
              0.5,
              0,
              1
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Stage Lighting Simulator\n// A Three.js scene demonstrating concert/stage lighting effects\n//\n// @param cameraSpeed float 0.002 [0, 0.01] \"Camera rotation speed\"\n// @param movingHeadSpeed float 0.5 [0.1, 2.0] \"Moving head animation speed\"\n// @param ledBarSpeed float 0.3 [0.1, 1.0] \"LED bar color cycle speed\"\n// @param hazeOpacity float 0.4 [0, 1] \"Haze particle opacity\"\n// @param blinderFlashRate float 2.0 [0.5, 5.0] \"Blinder flash rate\"\n// @param spotIntensity float 50 [10, 100] \"Spot light intensity\"\n// @param movingHeadIntensity float 80 [20, 150] \"Moving head intensity\"\n// @param autoRotate int 1 [0, 1] \"Camera auto-rotation\"\n\nfunction setup(THREE, canvas, params, channels, mouse) {\n  // Scene setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x050508);\n  scene.fog = new THREE.FogExp2(0x050508, 0.015);\n\n  const camera = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 1000);\n  camera.position.set(0, 8, 25);\n  camera.lookAt(0, 3, 0);\n\n  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });\n  renderer.setSize(canvas.width, canvas.height, false);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n  // Ambient light (very dim)\n  const ambient = new THREE.AmbientLight(0x111122, 0.3);\n  scene.add(ambient);\n\n  // Stage floor\n  const stageGeo = new THREE.BoxGeometry(30, 0.5, 20);\n  const stageMat = new THREE.MeshStandardMaterial({\n    color: 0x1a1a1a,\n    roughness: 0.8,\n    metalness: 0.2\n  });\n  const stage = new THREE.Mesh(stageGeo, stageMat);\n  stage.position.y = -0.25;\n  stage.receiveShadow = true;\n  scene.add(stage);\n\n  // Back wall\n  const wallGeo = new THREE.BoxGeometry(30, 15, 0.5);\n  const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9 });\n  const backWall = new THREE.Mesh(wallGeo, wallMat);\n  backWall.position.set(0, 7, -10);\n  backWall.receiveShadow = true;\n  scene.add(backWall);\n\n  // Truss system\n  const trussMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 });\n\n  function createTruss(length) {\n    const group = new THREE.Group();\n    const radius = 0.08;\n\n    const positions = [[-0.3, 0.3], [0.3, 0.3], [-0.3, -0.3], [0.3, -0.3]];\n\n    positions.forEach(([y, z]) => {\n      const geo = new THREE.CylinderGeometry(radius, radius, length, 8);\n      geo.rotateZ(Math.PI / 2);\n      const mesh = new THREE.Mesh(geo, trussMat);\n      mesh.position.set(0, y, z);\n      group.add(mesh);\n    });\n\n    const braceCount = Math.floor(length / 2);\n    for (let i = 0; i <= braceCount; i++) {\n      const x = -length/2 + i * (length / braceCount);\n      const ringGeo = new THREE.TorusGeometry(0.35, 0.04, 8, 4);\n      ringGeo.rotateY(Math.PI / 2);\n      const ring = new THREE.Mesh(ringGeo, trussMat);\n      ring.position.x = x;\n      group.add(ring);\n    }\n\n    return group;\n  }\n\n  // Trusses\n  const frontTruss = createTruss(28);\n  frontTruss.position.set(0, 10, 5);\n  scene.add(frontTruss);\n\n  const backTruss = createTruss(28);\n  backTruss.position.set(0, 12, -5);\n  scene.add(backTruss);\n\n  const leftTruss = createTruss(12);\n  leftTruss.rotation.y = Math.PI / 2;\n  leftTruss.position.set(-14, 10, 0);\n  scene.add(leftTruss);\n\n  const rightTruss = createTruss(12);\n  rightTruss.rotation.y = Math.PI / 2;\n  rightTruss.position.set(14, 10, 0);\n  scene.add(rightTruss);\n\n  // Arrays to store animated lights\n  const movingHeads = [];\n  const spotLights = [];\n  const barLights = [];\n\n  // Helper to create volumetric cone\n  function createLightCone(color, angle = 0.4, length = 12) {\n    const coneGeo = new THREE.ConeGeometry(Math.tan(angle) * length, length, 32, 1, true);\n    const coneMat = new THREE.MeshBasicMaterial({\n      color: color,\n      transparent: true,\n      opacity: 0.08,\n      side: THREE.DoubleSide,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false\n    });\n    const cone = new THREE.Mesh(coneGeo, coneMat);\n    cone.rotation.x = Math.PI;\n    cone.position.y = -length / 2;\n    return cone;\n  }\n\n  // Create fixture housing\n  function createFixtureHousing(type = 'spot') {\n    const group = new THREE.Group();\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.7, roughness: 0.3 });\n\n    if (type === 'moving') {\n      const yokeGeo = new THREE.BoxGeometry(0.6, 0.8, 0.15);\n      const yoke = new THREE.Mesh(yokeGeo, housingMat);\n      group.add(yoke);\n\n      const headGroup = new THREE.Group();\n      const headGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.7, 16);\n      headGeo.rotateX(Math.PI / 2);\n      const head = new THREE.Mesh(headGeo, housingMat);\n      headGroup.add(head);\n\n      const lensGeo = new THREE.CircleGeometry(0.3, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.position.z = 0.36;\n      headGroup.add(lens);\n\n      headGroup.position.y = -0.4;\n      group.add(headGroup);\n      group.headGroup = headGroup;\n      group.lens = lens;\n    } else if (type === 'spot') {\n      const bodyGeo = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI;\n      group.add(body);\n\n      const lensGeo = new THREE.CircleGeometry(0.33, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.rotation.x = Math.PI / 2;\n      lens.position.y = -0.41;\n      group.add(lens);\n    } else if (type === 'par') {\n      const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI / 2;\n      group.add(body);\n    }\n\n    return group;\n  }\n\n  // SPOT LIGHTS - Front truss\n  const spotColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];\n  for (let i = 0; i < 6; i++) {\n    const x = -12 + i * 4.8;\n    const color = spotColors[i];\n\n    const fixture = createFixtureHousing('spot');\n    fixture.position.set(x, 9.5, 5);\n    fixture.rotation.x = 0.3;\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.spotIntensity, 25, 0.4, 0.5, 1);\n    spot.position.set(x, 9.2, 5);\n    spot.target.position.set(x * 0.3, 0, -2);\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.4, 10);\n    cone.position.set(x, 9.2, 5);\n    cone.rotation.x = 0.3;\n    scene.add(cone);\n\n    spotLights.push({ light: spot, cone, fixture, baseX: x, color });\n  }\n\n  // MOVING HEADS - Back truss\n  const movingColors = [0xff0066, 0x00ffff, 0xff6600, 0x00ff66, 0x6600ff, 0xffff00];\n  for (let i = 0; i < 6; i++) {\n    const x = -10 + i * 4;\n    const color = movingColors[i];\n\n    const fixture = createFixtureHousing('moving');\n    fixture.position.set(x, 11.5, -5);\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.movingHeadIntensity, 30, 0.25, 0.3, 1);\n    spot.position.set(x, 10.8, -5);\n    spot.castShadow = true;\n    spot.shadow.mapSize.width = 512;\n    spot.shadow.mapSize.height = 512;\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.25, 14);\n    scene.add(cone);\n\n    movingHeads.push({\n      light: spot,\n      cone,\n      fixture,\n      baseX: x,\n      phase: i * Math.PI / 3,\n      color\n    });\n  }\n\n  // LED BARS\n  function createLEDBar(width, segments) {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(width, 0.15, 0.2);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const segmentWidth = width / segments;\n    const lights = [];\n\n    for (let i = 0; i < segments; i++) {\n      const x = -width/2 + segmentWidth/2 + i * segmentWidth;\n      const ledGeo = new THREE.PlaneGeometry(segmentWidth * 0.8, 0.1);\n      const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });\n      const led = new THREE.Mesh(ledGeo, ledMat);\n      led.position.set(x, 0.08, 0);\n      led.rotation.x = -Math.PI / 2;\n      group.add(led);\n\n      const pointLight = new THREE.PointLight(0xffffff, 2, 4);\n      pointLight.position.set(x, 0.2, 0);\n      group.add(pointLight);\n\n      lights.push({ mesh: led, light: pointLight, index: i });\n    }\n\n    group.lights = lights;\n    return group;\n  }\n\n  const frontBar1 = createLEDBar(8, 12);\n  frontBar1.position.set(-8, 0.1, 8);\n  frontBar1.rotation.x = -0.2;\n  scene.add(frontBar1);\n  barLights.push({ bar: frontBar1, phase: 0 });\n\n  const frontBar2 = createLEDBar(8, 12);\n  frontBar2.position.set(8, 0.1, 8);\n  frontBar2.rotation.x = -0.2;\n  scene.add(frontBar2);\n  barLights.push({ bar: frontBar2, phase: Math.PI });\n\n  const backBar = createLEDBar(20, 24);\n  backBar.position.set(0, 0.1, -8);\n  backBar.rotation.x = 0.8;\n  scene.add(backBar);\n  barLights.push({ bar: backBar, phase: 0, isBack: true });\n\n  // WASH LIGHTS\n  const washColors = [0xff3366, 0x3366ff, 0xff3366, 0x3366ff];\n  const washPositions = [[-14, 10, 4], [-14, 10, -4], [14, 10, 4], [14, 10, -4]];\n\n  washPositions.forEach((pos, i) => {\n    const color = washColors[i];\n    const wash = new THREE.SpotLight(color, 40, 25, 0.8, 0.8, 1);\n    wash.position.set(...pos);\n    wash.target.position.set(0, 0, pos[2] * 0.5);\n    scene.add(wash);\n    scene.add(wash.target);\n\n    const cone = createLightCone(color, 0.8, 12);\n    cone.position.set(...pos);\n    cone.rotation.z = i < 2 ? 0.5 : -0.5;\n    scene.add(cone);\n  });\n\n  // BLINDERS\n  function createBlinder() {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(2, 0.8, 0.4);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const cells = [];\n    for (let i = 0; i < 4; i++) {\n      const x = -0.75 + i * 0.5;\n      const cellGeo = new THREE.CircleGeometry(0.18, 16);\n      const cellMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const cell = new THREE.Mesh(cellGeo, cellMat);\n      cell.position.set(x, 0, 0.21);\n      group.add(cell);\n\n      const light = new THREE.SpotLight(0xffffcc, 0, 15, 0.6, 0.5, 1);\n      light.position.set(x, 0, 0.3);\n      light.target.position.set(x, -5, 10);\n      group.add(light);\n      group.add(light.target);\n\n      cells.push({ mesh: cell, light });\n    }\n\n    group.cells = cells;\n    return group;\n  }\n\n  const blinder = createBlinder();\n  blinder.position.set(0, 9.5, 5.3);\n  blinder.rotation.x = 0.4;\n  scene.add(blinder);\n\n  // Haze particles\n  const hazeGeo = new THREE.BufferGeometry();\n  const hazeCount = 2000;\n  const hazePositions = new Float32Array(hazeCount * 3);\n\n  for (let i = 0; i < hazeCount; i++) {\n    hazePositions[i * 3] = (Math.random() - 0.5) * 30;\n    hazePositions[i * 3 + 1] = Math.random() * 15;\n    hazePositions[i * 3 + 2] = (Math.random() - 0.5) * 25;\n  }\n\n  hazeGeo.setAttribute('position', new THREE.BufferAttribute(hazePositions, 3));\n  const hazeMat = new THREE.PointsMaterial({\n    color: 0x666688,\n    size: 0.08,\n    transparent: true,\n    opacity: params.hazeOpacity,\n    blending: THREE.AdditiveBlending\n  });\n  const haze = new THREE.Points(hazeGeo, hazeMat);\n  scene.add(haze);\n\n  return {\n    scene,\n    camera,\n    renderer,\n    objects: {\n      movingHeads,\n      spotLights,\n      barLights,\n      blinder,\n      haze,\n      hazeMat,\n      hazeCount,\n      cameraAngle: 0\n    }\n  };\n}\n\nfunction animate(time, delta, params, objects, mouse, channels) {\n  const { movingHeads, spotLights, barLights, blinder, haze, hazeMat, hazeCount } = objects;\n  const THREE = window.THREE;\n\n  // Update haze opacity from params\n  hazeMat.opacity = params.hazeOpacity;\n\n  // Animate moving heads\n  movingHeads.forEach((mh, i) => {\n    const speed = params.movingHeadSpeed;\n    const pan = Math.sin(time * speed + mh.phase) * 0.8;\n    const tilt = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 0.3 + 0.5;\n\n    if (mh.fixture.headGroup) {\n      mh.fixture.headGroup.rotation.x = tilt;\n      mh.fixture.rotation.y = pan;\n    }\n\n    const targetX = mh.baseX + Math.sin(time * speed + mh.phase) * 8;\n    const targetZ = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 5;\n    mh.light.target.position.set(targetX, 0, targetZ);\n\n    mh.cone.position.copy(mh.light.position);\n    const dir = new THREE.Vector3().subVectors(mh.light.target.position, mh.light.position).normalize();\n    mh.cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir);\n\n    // Color cycling\n    const hue = (time * 0.1 + i * 0.1) % 1;\n    const color = new THREE.Color().setHSL(hue, 1, 0.5);\n    mh.light.color = color;\n    mh.light.intensity = params.movingHeadIntensity;\n    mh.cone.material.color = color;\n    if (mh.fixture.lens) mh.fixture.lens.material.color = color;\n  });\n\n  // Animate LED bars\n  const ledSpeed = params.ledBarSpeed;\n  barLights.forEach((bl) => {\n    bl.bar.lights.forEach((led, i) => {\n      const hue = (time * ledSpeed + i * 0.05 + bl.phase) % 1;\n      const brightness = (Math.sin(time * 3 + i * 0.3 + bl.phase) + 1) / 2;\n      const color = new THREE.Color().setHSL(hue, 1, 0.5 * brightness + 0.2);\n      led.mesh.material.color = color;\n      led.light.color = color;\n      led.light.intensity = brightness * 3;\n    });\n  });\n\n  // Blinder flash effect\n  const blinderOn = Math.sin(time * params.blinderFlashRate) > 0.9;\n  blinder.cells.forEach((cell) => {\n    cell.light.intensity = blinderOn ? 100 : 0;\n    cell.mesh.material.color.setHex(blinderOn ? 0xffffff : 0x333322);\n  });\n\n  // Animate spot light intensity\n  spotLights.forEach((sl, i) => {\n    const pulse = (Math.sin(time * 2 + i * 0.5) + 1) / 2;\n    sl.light.intensity = params.spotIntensity * (0.6 + pulse * 0.4);\n    sl.cone.material.opacity = 0.05 + pulse * 0.05;\n  });\n\n  // Haze drift\n  const positions = haze.geometry.attributes.position.array;\n  for (let i = 0; i < hazeCount; i++) {\n    positions[i * 3 + 1] += 0.005;\n    if (positions[i * 3 + 1] > 15) positions[i * 3 + 1] = 0;\n  }\n  haze.geometry.attributes.position.needsUpdate = true;\n\n  // Camera auto-rotation\n  if (params.autoRotate === 1) {\n    objects.cameraAngle += params.cameraSpeed;\n  }\n}\n\nfunction cleanup(objects) {\n  if (objects.haze) {\n    objects.haze.geometry.dispose();\n    objects.hazeMat.dispose();\n  }\n}\n",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "scene"
        }
      ]
    },
    {
      "name": "Mixes 1",
      "type": "mix",
      "mixPresets": [
        {
          "name": "Mix 1",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            {
              "alpha": 1,
              "params": {
                "speed": 1.45,
                "p0": 0.5,
                "p1": 0.5,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {
                "roomColor": [
                  0.3607843137254902,
                  0.17647058823529413,
                  0.17647058823529413
                ]
              },
              "shaderCode": "// Fractal tunnel effect\n// Based on shader from coyote => https://www.shadertoy.com/view/ltfGzS\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @param roomColor color [1.0, 0.3, 0.1] \"Fire color\"\n// matrix op\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\n//mat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n    float t = iDate.w*.2, c,d,m;\n    vec3 p=vec3((2.*fragCoord.xy-s)/s.x,1.),r=p-p,q=r;\n    //p*=getRotZMat(-t);\n    p*=getRotYMat(-t);\n   \tq.zx += 10.+vec2(sin(t),cos(t))*3.;\n    for (float i=1.; i>0.; i-=.01) {\n        c=d=0.,m=1.;\n\t\tfor (int j = 0; j < 3 ; j++)\n            r=max(r*=r*=r*=r=mod(q*m+1.,2.)-1.,r.yzx),\n            d=max(d,( .29 -length(r)*.6)/m)*.8,\n            m*=1.1;\n\n        q+=p*d;\n        \n        c = i;\n\t    \n        if(d<1e-5) break;\n    }\n    \n    float k = dot(r,r+.15);\n    fragColor.rgb = vec3(1.,k,k/c) - (1. - roomColor);\n    \n}"
            },
            {
              "alpha": 1,
              "params": {
                "speed": 1.22,
                "p0": 0.05,
                "p1": 0.49,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 0,
                "g0": 0,
                "b0": 0,
                "r1": 0,
                "g1": 0,
                "b1": 0,
                "r2": 0,
                "g2": 0,
                "b2": 0,
                "r3": 0,
                "g3": 0,
                "b3": 0,
                "r4": 0,
                "g4": 0,
                "b4": 0,
                "r5": 0,
                "g5": 0,
                "b5": 0,
                "r6": 0,
                "g6": 0,
                "b6": 0,
                "r7": 0,
                "g7": 0,
                "b7": 0,
                "r8": 0,
                "g8": 0,
                "b8": 0,
                "r9": 0,
                "g9": 0,
                "b9": 0
              },
              "customParams": {},
              "shaderCode": "// Custom params: // @param name type [default] [min, max] \"description\"\n\n/*\n\n    Bumped Sinusoidal Warp\n    ----------------------\n\n    Sinusoidal planar deformation, or the 2D sine warp effect to people \n    like me. The effect has been around for years, and there are\n    countless examples on the net. IQ's \"Sculpture III\" is basically a \n    much more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n    turn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n    the frequency and iteration count in order to make it less busy.\n\n    I also threw in a texture, added point-lit bump mapping, speckles... \n    and that's pretty much it. As for why a metallic surface would be \n    defying\tthe laws of physics and moving like this is anyone's guess. :)\n\n    By the way, I have a 3D version, similar to this, that I'll put up at \n    a later date.\n    \n\n\n    Related examples:\n\n    Fantomas - Plop\n    https://www.shadertoy.com/view/ltSSDV\n\n    Fabrice - Plop 2\n    https://www.shadertoy.com/view/MlSSDV\n\n    IQ - Sculpture III (loosely related)\n    https://www.shadertoy.com/view/XtjSDK\n\n    Shane - Lit Sine Warp (far less code)\n    https://www.shadertoy.com/view/Ml2XDV\n\n*/\n\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p + 3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos(p.yx*3. + vec2(t, 1.57))/3.;\n        p += sin(p.yx + t + vec2(1.57, 0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p += fract(sin(p+vec2(13, 7))*5e5)*.03 - .015;\n\n    return mod(p, 2.) - 1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, \n// we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n    return length(W(p))*.7071; // Range: [0, 1]\n\n}\n\n/*\n// Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*/\n\nvec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //float th = sin(iTime*0.1)*sin(iTime*0.12)*2.;\n    //float cs = cos(th), si = sin(th);\n    //uv *= mat2(cs, -si, si, cs);\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a \n    // bump mapped plane situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion, or hit point. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.2, -1); // Light position - Back from the screen.\n    vec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n \n     \n/*\n    // I deliberately left this block in to show that the above is a simplified version\n    // of a raytraced plane. The \"rayPlane\" equation is commented out above.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0, 0, -1);\n\n    // Plane normal.\n    vec3 sn = normalize(vec3(cos(iTime)*.25, sin(iTime)*.25, -1));\n    //vec3 sn = normalize(vec3(0, 0, -1));\n    \n    vec3 sp = rayPlane(vec3(0), ro, sn, rd);\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.25, -1); \n*/    \n    \n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n   \n    // Controls how much the bump is accentuated.\n    const float bumpFactor = .05;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize(sn + grad*bumpFactor ); \n    sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);   \n    // Equivalent to the following.\n    //sn = cross(-vec3(1, 0, fx*bumpFactor), vec3(0, 1, fy*bumpFactor));\n    //sn = normalize(sn);\n   \n    \n    // LIGHTING\n    //\n    // Determine the light direction vector, calculate its distance, then normalize it.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*.15);\n    //float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n    \n\n    // Diffuse value.\n    float diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n    //float spec = pow(max(dot(normalize(ld - rd), sn), 0.), 32.);\n    \n    \n    // TEXTURE COLOR\n    //\n    // Combining the surface postion with a fraction of the warped surface position to index \n    // into the texture. The result is a slightly warped texture, as a opposed to a completely \n    // warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    // so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    // it's more readable this way.\n    vec3 texCol = texture(iChannel0, sp.xy + W(sp.xy)/8.).xyz; \n    texCol *= texCol; // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    // A bit of color processing.\n    texCol = smoothstep(.05, .75, pow(texCol, vec3(.75, .8, .85)));    \n    \n    // Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    //vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .2;\n    \n    \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*vec3(1, .97, .92)*2. + .5) + vec3(1, .6, .2)*spec*2.)*atten;\n    \n    // Faux environment mapping: I added this in at a later date out of sheer boredome, and  \n    // because I like shiny stuff. You can comment it out if it's not to your liking. :)\n    float ref = max(dot(reflect(rd, sn), vec3(1)), 0.);\n    col += col*pow(ref, 4.)*vec3(.25, .5, 1)*3.;\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}"
            },
            {
              "alpha": 1,
              "params": {
                "red": 1,
                "green": 1,
                "blue": 1,
                "red2": 1,
                "green2": 1,
                "blue2": 1,
                "red3": 1,
                "green3": 1,
                "blue3": 1,
                "speed": 1,
                "param1": 0.5,
                "param2": 0.5
              },
              "customParams": {},
              "shaderCode": "// ShaderShow - Default Shader\n// A colorful animated pattern demonstrating Shadertoy uniforms\n// Custom params: // @param name type [default] [min, max] \"description\"\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    // Mouse interaction - brighten area near cursor\n    if (iMouse.z > 0.0) {\n        vec2 mouseUV = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n        float mouseDist = length(uv0 - mouseUV);\n        finalColor += vec3(0.2) * smoothstep(0.5, 0.0, mouseDist);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n"
            },
            null
          ]
        },
        {
          "name": "Mix 2",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.9254901960784314,
                  0.03529411764705882,
                  0.03529411764705882
                ]
              },
              "customParams": {
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.9254901960784314,
                  0.6431372549019608,
                  0.03529411764705882
                ]
              },
              "shaderCode": "// Fire shader - Parametric flame effect\n\n// @param iterations float 0.5 [0.0, 1.0] \"Iteration depth\"\n// @param amplitude float 0.5 [0.0, 1.0] \"Wave amplitude\"\n// @param zoom float 0.5 [0.1, 1.0] \"Zoom level\"\n// @param fireColor color [1.0, 0.3, 0.1] \"Fire color\"\n\n/*\n    @SnoopethDuckDuck -6 chars\n    @Xor              -1 chars\n\n    Thanks! :D\n\n*/\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(--r)*.1,\n        o += 1. / r)\n        for(p = vec3((u-z.xy/(2. * 2.0 * zoom))/z.y * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*(.6 + 5.0 * amplitude),\n            r =  cos(p.z),\n            e = 1.6 + iterations;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), z/z)) / e;\n    o = tanh(vec4(fireColor,1) * o * o / f / 7e6);\n}\n\n\n\n/* you can put it out with this :D\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float s=.002,i,n;\n    vec3 r = iResolution,p;\n    for(o *= i; i++ < 40. && s > .001;) {\n        s = 1. + (p += vec3((u-r.xy/2.)/r.y,1) * s).y;\n        for (n =.5; n < 20.;n+=n)\n            s += abs(dot(sin(p.z+iTime+p * n), vec3(.1))) / n;\n        o += s *.03+.03;\n    }\n    o = tanh(o);\n}\n\n*/\n\n\n/* original fire shader\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(r)*.1,\n        o += 1. / r)\n        for(p = vec3(((u-z.xy/2.)/z.y) * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*.6,\n            r =  cos(p.z)-1.,\n            e = 1.6;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), vec3(1))) / e;\n    o = tanh(vec4(6,2,1,1) * o * o / f / 7e6);\n}\n\n*/"
            },
            null,
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  1,
                  1,
                  1
                ],
                "light2": [
                  1,
                  1,
                  1
                ],
                "light3": [
                  1,
                  1,
                  1
                ],
                "light4": [
                  1,
                  1,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  1
                ],
                "light7": [
                  1,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "customParams": {
                "showGround": 0.32,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  0.30980392156862746,
                  0.9803921568627451,
                  0.0196078431372549
                ],
                "light2": [
                  1,
                  0,
                  0
                ],
                "light3": [
                  0,
                  0,
                  1
                ],
                "light4": [
                  1,
                  0,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  0
                ],
                "light7": [
                  0,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "shaderCode": "// Stage Lights Array Simulation - OPTIMIZED\n// Creates an array of animated stage lights with volumetric fog\n\n// @param showGround float 0.5 [0.0, 1.0] \"Show ground (>0.5)\"\n// @param lightHeight float 0.5 [0.0, 1.0] \"Light height\"\n// @param lightDepth float 0.5 [0.0, 1.0] \"Light depth\"\n// @param light1 color [1.0, 0.0, 0.0] \"Light 1\"\n// @param light2 color [0.0, 1.0, 0.0] \"Light 2\"\n// @param light3 color [0.0, 0.0, 1.0] \"Light 3\"\n// @param light4 color [1.0, 1.0, 0.0] \"Light 4\"\n// @param light5 color [1.0, 0.0, 1.0] \"Light 5\"\n// @param light6 color [0.0, 1.0, 1.0] \"Light 6\"\n// @param light7 color [1.0, 0.5, 0.0] \"Light 7\"\n// @param light8 color [0.5, 0.0, 1.0] \"Light 8\"\n\n#define NUM_LIGHTS 8\n#define PI 3.14159265359\n#define MAX_STEPS 88  // Reduziert von ~100\n\n// Vereinfachte Noise-Funktion\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Schnellerer Noise - weniger Operationen\nfloat noise2(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    float e = hash(n + 113.0);\n    float f1 = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    return mix(mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n               mix(mix(e, f1, f.x), mix(g, h, f.x), f.y), f.z);\n}\n\nfloat noise(vec3 x){\n  return 1.0;\n}\n// Vorberechnete Lichtdaten\nstruct Light {\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    float angle;\n    float intensity;\n};\n\n// Lichtparameter einmal pro Frame berechnen\nvoid setupLights(out Light lights[NUM_LIGHTS]) {\n    // Build color array from named parameters\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = light1;\n    lightColors[1] = light2;\n    lightColors[2] = light3;\n    lightColors[3] = light4;\n    lightColors[4] = light5;\n    lightColors[5] = light6;\n    lightColors[6] = light7;\n    lightColors[7] = light8;\n\n    for (int j = 0; j < NUM_LIGHTS; j++) {\n        float lightIndex = float(j);\n        float phase = lightIndex * PI * 2.0 / float(NUM_LIGHTS);\n        float swing = sin(iTime * 0.5 + phase) * 0.3;\n        float tilt = cos(iTime * 0.7 + phase * 1.5) * 0.2;\n\n        lights[j].pos = vec3(-3.5 + lightIndex * 1.0, 3.0 * lightHeight + 3.0, 10.0 * lightDepth - 10.0);\n        lights[j].dir = normalize(vec3(swing, -0.8 + tilt, 1.0));\n        lights[j].angle = 0.3 + 0.1 * sin(iTime + phase);\n\n        // Flicker\n        float flicker = 0.9 + 0.1 * sin(iTime * 20.0 + lightIndex * 7.0);\n        lights[j].intensity = 2.0 * flicker;\n        lights[j].color = lightColors[j];\n    }\n}\n\n// Optimierte Spotlight-Berechnung\nvec3 spotlightFast(vec3 pos, Light light, float fog) {\n    vec3 toLight = light.pos - pos;\n    float dist2 = dot(toLight, toLight);  // Quadrat statt length()\n    vec3 lightVec = toLight * inversesqrt(dist2);\n    \n    float spotEffect = dot(lightVec, -light.dir);\n    float spotCutoff = cos(light.angle);\n    \n    if (spotEffect < spotCutoff) return vec3(0.0);\n    \n    float edge = smoothstep(spotCutoff, 1.0, spotEffect);\n    float dist = sqrt(dist2);\n    float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist2);\n    \n    return light.color * (edge * attenuation * fog * light.intensity);\n}\n\n// Optimiertes Ray Marching\nvec3 volumetricLighting(vec3 ro, vec3 rd, float maxDist, Light lights[NUM_LIGHTS]) {\n    vec3 color = vec3(0.0);\n    \n    // Adaptive Schrittweite\n    float stepSize = maxDist / float(MAX_STEPS);\n    stepSize = max(stepSize, 0.15);  // Minimum 0.15\n    \n    float t = stepSize * 0.5;  // Start mit halber Schrittweite (besseres Sampling)\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (t >= maxDist) break;\n        \n        vec3 pos = ro + rd * t;\n        \n        // Fog nur einmal pro Schritt berechnen\n        float fog = 0.1 + noise(pos * 0.5 + vec3(0.0, -iTime * 0.1, 0.0)) * 0.05;\n        \n        // Alle Lichter akkumulieren\n        vec3 lightContrib = vec3(0.0);\n        for (int j = 0; j < NUM_LIGHTS; j++) {\n            lightContrib += spotlightFast(pos, lights[j], fog);\n        }\n        \n        color += lightContrib;\n        t += stepSize;\n    }\n    \n    return color * stepSize;\n}\n\nfloat groundPlane(vec3 ro, vec3 rd) {\n    return rd.y < 0.0 ? -ro.y / rd.y : -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Lichter einmal pro Pixel vorberechnen\n    Light lights[NUM_LIGHTS];\n    setupLights(lights);\n    \n    // Camera\n    vec3 ro = vec3(0.0, 1.5, 5.0);\n    vec3 forward = normalize(vec3(0.0, 1.0, 0.0) - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Background\n    vec3 color = vec3(0.02, 0.02, 0.05) * (1.0 - uv.y * 0.5);\n    \n    // Ground\n    float groundT = 0.0;\n    if(showGround >= 0.5){\n    groundT = groundPlane(ro, rd);\n    if (groundT > 0.0) {\n        vec3 groundPos = ro + rd * groundT;\n        vec2 checker = floor(groundPos.xz * 2.0);\n        float pattern = mod(checker.x + checker.y, 2.0);\n        color = mix(color, mix(vec3(0.05), vec3(0.1), pattern), exp(-groundT * 0.1));\n    }\n    }\n    // Volumetric lighting\n    color += volumetricLighting(ro, rd, groundT > 0.0 ? groundT : 10.0, lights);\n    \n    // Tonemapping + Gamma + Vignette kombiniert\n    color = pow(color / (1.0 + color), vec3(0.4545)) * (1.0 - dot(uv, uv) * 0.3);\n    if(uv.y < 0.48 || uv.y > 0.52){\n      fragColor = vec4(color, 1.0);\n    } else {\n      fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n} "
            },
            null
          ]
        },
        {
          "name": "Mix 3",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            {
              "alpha": 0.23,
              "params": {
                "speed": 1.45,
                "p0": 0.5,
                "p1": 0.5,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {
                "roomColor": [
                  0.3607843137254902,
                  0.17647058823529413,
                  0.17647058823529413
                ]
              },
              "shaderCode": "// Fractal tunnel effect\n// Based on shader from coyote => https://www.shadertoy.com/view/ltfGzS\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @param roomColor color [1.0, 0.3, 0.1] \"Fire color\"\n// matrix op\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\n//mat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n    float t = iDate.w*.2, c,d,m;\n    vec3 p=vec3((2.*fragCoord.xy-s)/s.x,1.),r=p-p,q=r;\n    //p*=getRotZMat(-t);\n    p*=getRotYMat(-t);\n   \tq.zx += 10.+vec2(sin(t),cos(t))*3.;\n    for (float i=1.; i>0.; i-=.01) {\n        c=d=0.,m=1.;\n\t\tfor (int j = 0; j < 3 ; j++)\n            r=max(r*=r*=r*=r=mod(q*m+1.,2.)-1.,r.yzx),\n            d=max(d,( .29 -length(r)*.6)/m)*.8,\n            m*=1.1;\n\n        q+=p*d;\n        \n        c = i;\n\t    \n        if(d<1e-5) break;\n    }\n    \n    float k = dot(r,r+.15);\n    fragColor.rgb = vec3(1.,k,k/c) - (1. - roomColor);\n    \n}"
            },
            {
              "alpha": 0.25,
              "params": {
                "speed": 1.22,
                "p0": 0.05,
                "p1": 0.49,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 0,
                "g0": 0,
                "b0": 0,
                "r1": 0,
                "g1": 0,
                "b1": 0,
                "r2": 0,
                "g2": 0,
                "b2": 0,
                "r3": 0,
                "g3": 0,
                "b3": 0,
                "r4": 0,
                "g4": 0,
                "b4": 0,
                "r5": 0,
                "g5": 0,
                "b5": 0,
                "r6": 0,
                "g6": 0,
                "b6": 0,
                "r7": 0,
                "g7": 0,
                "b7": 0,
                "r8": 0,
                "g8": 0,
                "b8": 0,
                "r9": 0,
                "g9": 0,
                "b9": 0
              },
              "customParams": {},
              "shaderCode": "// Custom params: // @param name type [default] [min, max] \"description\"\n\n/*\n\n    Bumped Sinusoidal Warp\n    ----------------------\n\n    Sinusoidal planar deformation, or the 2D sine warp effect to people \n    like me. The effect has been around for years, and there are\n    countless examples on the net. IQ's \"Sculpture III\" is basically a \n    much more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n    turn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n    the frequency and iteration count in order to make it less busy.\n\n    I also threw in a texture, added point-lit bump mapping, speckles... \n    and that's pretty much it. As for why a metallic surface would be \n    defying\tthe laws of physics and moving like this is anyone's guess. :)\n\n    By the way, I have a 3D version, similar to this, that I'll put up at \n    a later date.\n    \n\n\n    Related examples:\n\n    Fantomas - Plop\n    https://www.shadertoy.com/view/ltSSDV\n\n    Fabrice - Plop 2\n    https://www.shadertoy.com/view/MlSSDV\n\n    IQ - Sculpture III (loosely related)\n    https://www.shadertoy.com/view/XtjSDK\n\n    Shane - Lit Sine Warp (far less code)\n    https://www.shadertoy.com/view/Ml2XDV\n\n*/\n\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p + 3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos(p.yx*3. + vec2(t, 1.57))/3.;\n        p += sin(p.yx + t + vec2(1.57, 0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p += fract(sin(p+vec2(13, 7))*5e5)*.03 - .015;\n\n    return mod(p, 2.) - 1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, \n// we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n    return length(W(p))*.7071; // Range: [0, 1]\n\n}\n\n/*\n// Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*/\n\nvec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //float th = sin(iTime*0.1)*sin(iTime*0.12)*2.;\n    //float cs = cos(th), si = sin(th);\n    //uv *= mat2(cs, -si, si, cs);\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a \n    // bump mapped plane situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion, or hit point. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.2, -1); // Light position - Back from the screen.\n    vec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n \n     \n/*\n    // I deliberately left this block in to show that the above is a simplified version\n    // of a raytraced plane. The \"rayPlane\" equation is commented out above.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0, 0, -1);\n\n    // Plane normal.\n    vec3 sn = normalize(vec3(cos(iTime)*.25, sin(iTime)*.25, -1));\n    //vec3 sn = normalize(vec3(0, 0, -1));\n    \n    vec3 sp = rayPlane(vec3(0), ro, sn, rd);\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.25, -1); \n*/    \n    \n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n   \n    // Controls how much the bump is accentuated.\n    const float bumpFactor = .05;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize(sn + grad*bumpFactor ); \n    sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);   \n    // Equivalent to the following.\n    //sn = cross(-vec3(1, 0, fx*bumpFactor), vec3(0, 1, fy*bumpFactor));\n    //sn = normalize(sn);\n   \n    \n    // LIGHTING\n    //\n    // Determine the light direction vector, calculate its distance, then normalize it.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*.15);\n    //float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n    \n\n    // Diffuse value.\n    float diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n    //float spec = pow(max(dot(normalize(ld - rd), sn), 0.), 32.);\n    \n    \n    // TEXTURE COLOR\n    //\n    // Combining the surface postion with a fraction of the warped surface position to index \n    // into the texture. The result is a slightly warped texture, as a opposed to a completely \n    // warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    // so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    // it's more readable this way.\n    vec3 texCol = texture(iChannel0, sp.xy + W(sp.xy)/8.).xyz; \n    texCol *= texCol; // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    // A bit of color processing.\n    texCol = smoothstep(.05, .75, pow(texCol, vec3(.75, .8, .85)));    \n    \n    // Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    //vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .2;\n    \n    \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*vec3(1, .97, .92)*2. + .5) + vec3(1, .6, .2)*spec*2.)*atten;\n    \n    // Faux environment mapping: I added this in at a later date out of sheer boredome, and  \n    // because I like shiny stuff. You can comment it out if it's not to your liking. :)\n    float ref = max(dot(reflect(rd, sn), vec3(1)), 0.);\n    col += col*pow(ref, 4.)*vec3(.25, .5, 1)*3.;\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}"
            },
            {
              "alpha": 0.04,
              "params": {
                "red": 1,
                "green": 1,
                "blue": 1,
                "red2": 1,
                "green2": 1,
                "blue2": 1,
                "red3": 1,
                "green3": 1,
                "blue3": 1,
                "speed": 1,
                "param1": 0.5,
                "param2": 0.5
              },
              "customParams": {},
              "shaderCode": "// ShaderShow - Default Shader\n// A colorful animated pattern demonstrating Shadertoy uniforms\n// Custom params: // @param name type [default] [min, max] \"description\"\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    // Mouse interaction - brighten area near cursor\n    if (iMouse.z > 0.0) {\n        vec2 mouseUV = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n        float mouseDist = length(uv0 - mouseUV);\n        finalColor += vec3(0.2) * smoothstep(0.5, 0.0, mouseDist);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n"
            },
            {
              "alpha": 1,
              "params": {
                "speed": 1.22,
                "p0": 0.05,
                "p1": 0.49,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {},
              "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*.03, s - iTime*.1)).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - .4);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 f1 = flame(u+vec2( 7.5,0.2),.1,vec3(.9,.4,.1),vec3(.9,.7,.3));\n    vec3 f2 = flame(u+vec2( 6.,0.),.2,vec3(.2,.6,.7),vec3(.6,.8,.9));\n    vec3 f3 = flame(u+vec2( 4.5,0.),.3,vec3(.9,.0,.0),vec3(.9,.3,.0));\n    vec3 f4 = flame(u+vec2( 3.,0.),.4,vec3(.2,.3,.8),vec3(.9,.6,.9));\n    vec3 f5 = flame(u+vec2( 1.5,0.),.5,vec3(.9,.4,.6),vec3(.9,.7,.3));\n    vec3 f6 = flame(u+vec2( 0.,0.),.6,vec3(.2,.6,.7),vec3(.6,.8,.9));\n    vec3 f7 = flame(u+vec2( -1.5,0.),.7,vec3(.9,.4,.3),vec3(1.,.8,.5));\n    vec3 f8 = flame(u+vec2(-3.,0.),.8,vec3(.2,.3,.8),vec3(.9,.6,.9));\n\n    vec3 C = f1+f2+f3+f4+f5+f6+f7+f8;\n    O = vec4(C+C,1.0);\n}"
            }
          ]
        },
        {
          "name": "Mix 4",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "p0": 0.5,
                "p1": 0.5,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {},
              "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    \n    float pi = 3.1415926535897; \n\n     \n    float cx = uv.x+0.5*sin(iTime/5.0); \n    float cy = uv.y+0.5*cos(iTime/3.0); \n     \n    float v = sin(sqrt(100.0*(cx*cx+cy*cy))); \n    v += sin(uv.x*10.0+iTime); \n    v += cos(uv.y*4.0+iTime); \n     \n    fragColor = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0); \n    \n}"
            },
            {
              "alpha": 0,
              "params": {
                "speed": 1
              },
              "customParams": {
                "iFlame": 0.64,
                "light1": [
                  0.2,
                  0.30196078431372547,
                  0.8
                ],
                "light2": [
                  0.2,
                  0.6,
                  0.8
                ],
                "light3": [
                  0.9019607843137255,
                  0.4,
                  0.30196078431372547
                ],
                "light4": [
                  1,
                  0.54,
                  0.23
                ],
                "light5": [
                  0.9,
                  0.4,
                  0.3
                ],
                "light6": [
                  0.2,
                  0.3,
                  0.8
                ],
                "light7": [
                  0.9,
                  0,
                  1
                ],
                "light8": [
                  0.2,
                  0.3,
                  0.8
                ]
              },
              "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @texture iChannel0 RGBANoise\n// @param iFlame float 0.3 [0.0,5.0] \"Flamme\"\n// @param light1 color [0.9, 0.4, 0.1] \"Flame 1\"\n// @param light2 color [0.2, 0.6, 0.8] \"Flame 2\"\n// @param light3 color [0.9, 0.0, 1.0] \"Flame 3\"\n// @param light4 color [0.2, 0.3, 0.8] \"Flame 4\"\n// @param light5 color [0.9, 0.4, 0.6] \"Flame 5\"\n// @param light6 color [0.2, 0.6, 0.7] \"Flame 6\"\n// @param light7 color [0.9, 0.4, 0.3] \"Flame 7\"\n// @param light8 color [0.2, 0.3, 0.8] \"Flame 8\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*.03*iFlame, s - iTime*.1*iFlame)).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - .4);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 f1 = flame(u+vec2( 7.5,0.2),.1,light1,vec3(.9,.7,.3));\n    vec3 f2 = flame(u+vec2( 6.,0.),.2,light2,vec3(.6,.8,.9));\n    vec3 f3 = flame(u+vec2( 4.5,0.),.3,light3,vec3(.9,.3,.0));\n    vec3 f4 = flame(u+vec2( 3.,0.),.4,light4,vec3(.9,.6,.9));\n    vec3 f5 = flame(u+vec2( 1.5,0.),.5,light5,vec3(.9,.7,.3));\n    vec3 f6 = flame(u+vec2( 0.,0.),.6,light6,vec3(.6,.8,.9));\n    vec3 f7 = flame(u+vec2( -1.5,0.),.7,light7,vec3(1.,.8,.5));\n    vec3 f8 = flame(u+vec2(-3.,0.),.8,light8,vec3(.9,.6,.9));\n\n    vec3 C = f1+f2+f3+f4+f5+f6+f7+f8;\n    O = vec4(C+C,1.0);\n    \n}"
            },
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "amplification": 3.04,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  1,
                  0.3,
                  0.1
                ]
              },
              "customParams": {
                "amplification": 3.04,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  1,
                  0.3,
                  0.1
                ]
              },
              "shaderCode": "// Fire shader - Parametric flame effect\n\n// @param amplification float 1.0 [0.0,5.0] \"Verstaerkung\"\n// @param iterations float 0.5 [0.0, 1.0] \"Iteration depth\"\n// @param amplitude float 0.5 [0.0, 1.0] \"Wave amplitude\"\n// @param zoom float 0.5 [0.1, 1.0] \"Zoom level\"\n// @param fireColor color [1.0, 0.3, 0.1] \"Fire color\"\n\n/*\n    @SnoopethDuckDuck -6 chars\n    @Xor              -1 chars\n\n    Thanks! :D\n\n*/\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(--r)*.1,\n        o += 1. / r)\n        for(p = vec3((u-z.xy/(2. * 2.0 * zoom))/z.y * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*(.6 + 5.0 * amplitude),\n            r =  cos(p.z),\n            e = 1.6 + iterations;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), z/z)) / e;\n    o = amplification * tanh(vec4(fireColor,1) * o * o / f / 7e6);\n}\n\n\n\n/* you can put it out with this :D\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float s=.002,i,n;\n    vec3 r = iResolution,p;\n    for(o *= i; i++ < 40. && s > .001;) {\n        s = 1. + (p += vec3((u-r.xy/2.)/r.y,1) * s).y;\n        for (n =.5; n < 20.;n+=n)\n            s += abs(dot(sin(p.z+iTime+p * n), vec3(.1))) / n;\n        o += s *.03+.03;\n    }\n    o = tanh(o);\n}\n\n*/\n\n\n/* original fire shader\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(r)*.1,\n        o += 1. / r)\n        for(p = vec3(((u-z.xy/2.)/z.y) * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*.6,\n            r =  cos(p.z)-1.,\n            e = 1.6;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), vec3(1))) / e;\n    o = tanh(vec4(6,2,1,1) * o * o / f / 7e6);\n}\n\n*/"
            },
            null
          ]
        },
        {
          "name": "Mix 5",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "amplification": 3.04,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  1,
                  0.3,
                  0.1
                ]
              },
              "customParams": {
                "amplification": 3.04,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  1,
                  0.3,
                  0.1
                ]
              },
              "shaderCode": "// Fire shader - Parametric flame effect\n\n// @param amplification float 1.0 [0.0,5.0] \"Verstaerkung\"\n// @param iterations float 0.5 [0.0, 1.0] \"Iteration depth\"\n// @param amplitude float 0.5 [0.0, 1.0] \"Wave amplitude\"\n// @param zoom float 0.5 [0.1, 1.0] \"Zoom level\"\n// @param fireColor color [1.0, 0.3, 0.1] \"Fire color\"\n\n/*\n    @SnoopethDuckDuck -6 chars\n    @Xor              -1 chars\n\n    Thanks! :D\n\n*/\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(--r)*.1,\n        o += 1. / r)\n        for(p = vec3((u-z.xy/(2. * 2.0 * zoom))/z.y * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*(.6 + 5.0 * amplitude),\n            r =  cos(p.z),\n            e = 1.6 + iterations;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), z/z)) / e;\n    o = amplification * tanh(vec4(fireColor,1) * o * o / f / 7e6);\n}\n\n\n\n/* you can put it out with this :D\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float s=.002,i,n;\n    vec3 r = iResolution,p;\n    for(o *= i; i++ < 40. && s > .001;) {\n        s = 1. + (p += vec3((u-r.xy/2.)/r.y,1) * s).y;\n        for (n =.5; n < 20.;n+=n)\n            s += abs(dot(sin(p.z+iTime+p * n), vec3(.1))) / n;\n        o += s *.03+.03;\n    }\n    o = tanh(o);\n}\n\n*/\n\n\n/* original fire shader\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(r)*.1,\n        o += 1. / r)\n        for(p = vec3(((u-z.xy/2.)/z.y) * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*.6,\n            r =  cos(p.z)-1.,\n            e = 1.6;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), vec3(1))) / e;\n    o = tanh(vec4(6,2,1,1) * o * o / f / 7e6);\n}\n\n*/"
            },
            null,
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "p0": 0.5,
                "p1": 0.5,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {},
              "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    \n    float pi = 3.1415926535897; \n\n     \n    float cx = uv.x+0.5*sin(iTime/5.0); \n    float cy = uv.y+0.5*cos(iTime/3.0); \n     \n    float v = sin(sqrt(100.0*(cx*cx+cy*cy))); \n    v += sin(uv.x*10.0+iTime); \n    v += cos(uv.y*4.0+iTime); \n     \n    fragColor = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0); \n    \n}"
            },
            null
          ]
        },
        {
          "name": "Mix 6",
          "blendMode": "lighter",
          "thumbnail": "data:image/jpeg;base64,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",
          "channels": [
            null,
            {
              "alpha": 1,
              "params": {
                "speed": 1,
                "p0": 0.5,
                "p1": 0.5,
                "p2": 0.5,
                "p3": 0.5,
                "p4": 0.5,
                "r0": 1,
                "g0": 1,
                "b0": 1,
                "r1": 1,
                "g1": 1,
                "b1": 1,
                "r2": 1,
                "g2": 1,
                "b2": 1,
                "r3": 1,
                "g3": 1,
                "b3": 1,
                "r4": 1,
                "g4": 1,
                "b4": 1,
                "r5": 1,
                "g5": 1,
                "b5": 1,
                "r6": 1,
                "g6": 1,
                "b6": 1,
                "r7": 1,
                "g7": 1,
                "b7": 1,
                "r8": 1,
                "g8": 1,
                "b8": 1,
                "r9": 1,
                "g9": 1,
                "b9": 1
              },
              "customParams": {},
              "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    \n    float pi = 3.1415926535897; \n\n     \n    float cx = uv.x+0.5*sin(iTime/5.0); \n    float cy = uv.y+0.5*cos(iTime/3.0); \n     \n    float v = sin(sqrt(100.0*(cx*cx+cy*cy))); \n    v += sin(uv.x*10.0+iTime); \n    v += cos(uv.y*4.0+iTime); \n     \n    fragColor = vec4(sin(v*pi), cos(v*pi), sin(v*pi + 0.5*pi*v), 1.0); \n    \n}"
            }
          ]
        }
      ]
    },
    {
      "name": "Assets 1",
      "type": "assets",
      "slots": [
        {
          "shaderCode": null,
          "customParams": {
            "x": 0,
            "y": 0,
            "width": 960,
            "height": 1280,
            "scale": 1,
            "loop": 1,
            "start": 0,
            "end": 0
          },
          "presets": [],
          "type": "asset-video"
        }
      ]
    }
  ]
}