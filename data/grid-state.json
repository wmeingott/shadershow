{
  "version": 2,
  "activeTab": 0,
  "tabs": [
    {
      "name": "My Shaders",
      "slots": [
        {
          "shaderCode": "// Fire shader - Parametric flame effect\n\n// @param iterations float 0.5 [0.0, 1.0] \"Iteration depth\"\n// @param amplitude float 0.5 [0.0, 1.0] \"Wave amplitude\"\n// @param zoom float 0.5 [0.1, 1.0] \"Zoom level\"\n// @param fireColor color [1.0, 0.3, 0.1] \"Fire color\"\n\n/*\n    @SnoopethDuckDuck -6 chars\n    @Xor              -1 chars\n\n    Thanks! :D\n\n*/\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(--r)*.1,\n        o += 1. / r)\n        for(p = vec3((u-z.xy/(2. * 2.0 * zoom))/z.y * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*(.6 + 5.0 * amplitude),\n            r =  cos(p.z),\n            e = 1.6 + iterations;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), z/z)) / e;\n    o = tanh(vec4(fireColor,1) * o * o / f / 7e6);\n}\n\n\n\n/* you can put it out with this :D\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float s=.002,i,n;\n    vec3 r = iResolution,p;\n    for(o *= i; i++ < 40. && s > .001;) {\n        s = 1. + (p += vec3((u-r.xy/2.)/r.y,1) * s).y;\n        for (n =.5; n < 20.;n+=n)\n            s += abs(dot(sin(p.z+iTime+p * n), vec3(.1))) / n;\n        o += s *.03+.03;\n    }\n    o = tanh(o);\n}\n\n*/\n\n\n/* original fire shader\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float f, i, r, e,\n          t = iTime;\n    vec3 p, z = iResolution;\n    for(o*=i;\n        i++<1e2;\n        f += r = .01 + abs(r)*.1,\n        o += 1. / r)\n        for(p = vec3(((u-z.xy/2.)/z.y) * f, f+t),\n            p += cos(t+p.yzx+p.zzx)*.6,\n            r =  cos(p.z)-1.,\n            e = 1.6;\n            e < 32.;\n            e += e )\n            r += abs(dot(sin(t + p*e ), vec3(1))) / e;\n    o = tanh(vec4(6,2,1,1) * o * o / f / 7e6);\n}\n\n*/",
          "filePath": null,
          "params": {
            "speed": 1,
            "iterations": 0.5,
            "amplitude": 0.5,
            "zoom": 0.5,
            "fireColor": [
              0.9254901960784314,
              0.03529411764705882,
              0.03529411764705882
            ]
          },
          "customParams": {
            "iterations": 0.5,
            "amplitude": 0.5,
            "zoom": 0.5,
            "fireColor": [
              0.9254901960784314,
              0.6431372549019608,
              0.03529411764705882
            ]
          },
          "presets": [
            {
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.9254901960784314,
                  0.03529411764705882,
                  0.03529411764705882
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.30196078431372547,
                  0.9254901960784314,
                  0.03529411764705882
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.03529411764705882,
                  0.1843137254901961,
                  0.9254901960784314
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.9254901960784314,
                  0.807843137254902,
                  0.03529411764705882
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "iterations": 0.5,
                "amplitude": 0.5,
                "zoom": 0.5,
                "fireColor": [
                  0.9254901960784314,
                  0.6431372549019608,
                  0.03529411764705882
                ]
              },
              "name": null
            }
          ],
          "type": "shader"
        },
        {
          "shaderCode": "// ShaderShow - Default Shader\n// A colorful animated pattern demonstrating Shadertoy uniforms\n// Custom params: // @param name type [default] [min, max] \"description\"\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    // Mouse interaction - brighten area near cursor\n    if (iMouse.z > 0.0) {\n        vec2 mouseUV = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n        float mouseDist = length(uv0 - mouseUV);\n        finalColor += vec3(0.2) * smoothstep(0.5, 0.0, mouseDist);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
          "filePath": null,
          "params": {
            "red": 1,
            "green": 1,
            "blue": 1,
            "red2": 1,
            "green2": 1,
            "blue2": 1,
            "red3": 1,
            "green3": 1,
            "blue3": 1,
            "speed": 1,
            "param1": 0.5,
            "param2": 0.5
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Stage Lights Array Simulation - OPTIMIZED\n// Creates an array of animated stage lights with volumetric fog\n\n// @param showGround float 0.5 [0.0, 1.0] \"Show ground (>0.5)\"\n// @param lightHeight float 0.5 [0.0, 1.0] \"Light height\"\n// @param lightDepth float 0.5 [0.0, 1.0] \"Light depth\"\n// @param light1 color [1.0, 0.0, 0.0] \"Light 1\"\n// @param light2 color [0.0, 1.0, 0.0] \"Light 2\"\n// @param light3 color [0.0, 0.0, 1.0] \"Light 3\"\n// @param light4 color [1.0, 1.0, 0.0] \"Light 4\"\n// @param light5 color [1.0, 0.0, 1.0] \"Light 5\"\n// @param light6 color [0.0, 1.0, 1.0] \"Light 6\"\n// @param light7 color [1.0, 0.5, 0.0] \"Light 7\"\n// @param light8 color [0.5, 0.0, 1.0] \"Light 8\"\n\n#define NUM_LIGHTS 8\n#define PI 3.14159265359\n#define MAX_STEPS 88  // Reduziert von ~100\n\n// Vereinfachte Noise-Funktion\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Schnellerer Noise - weniger Operationen\nfloat noise2(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    float e = hash(n + 113.0);\n    float f1 = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    return mix(mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n               mix(mix(e, f1, f.x), mix(g, h, f.x), f.y), f.z);\n}\n\nfloat noise(vec3 x){\n  return 1.0;\n}\n// Vorberechnete Lichtdaten\nstruct Light {\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    float angle;\n    float intensity;\n};\n\n// Lichtparameter einmal pro Frame berechnen\nvoid setupLights(out Light lights[NUM_LIGHTS]) {\n    // Build color array from named parameters\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = light1;\n    lightColors[1] = light2;\n    lightColors[2] = light3;\n    lightColors[3] = light4;\n    lightColors[4] = light5;\n    lightColors[5] = light6;\n    lightColors[6] = light7;\n    lightColors[7] = light8;\n\n    for (int j = 0; j < NUM_LIGHTS; j++) {\n        float lightIndex = float(j);\n        float phase = lightIndex * PI * 2.0 / float(NUM_LIGHTS);\n        float swing = sin(iTime * 0.5 + phase) * 0.3;\n        float tilt = cos(iTime * 0.7 + phase * 1.5) * 0.2;\n\n        lights[j].pos = vec3(-3.5 + lightIndex * 1.0, 3.0 * lightHeight + 3.0, 10.0 * lightDepth - 10.0);\n        lights[j].dir = normalize(vec3(swing, -0.8 + tilt, 1.0));\n        lights[j].angle = 0.3 + 0.1 * sin(iTime + phase);\n\n        // Flicker\n        float flicker = 0.9 + 0.1 * sin(iTime * 20.0 + lightIndex * 7.0);\n        lights[j].intensity = 2.0 * flicker;\n        lights[j].color = lightColors[j];\n    }\n}\n\n// Optimierte Spotlight-Berechnung\nvec3 spotlightFast(vec3 pos, Light light, float fog) {\n    vec3 toLight = light.pos - pos;\n    float dist2 = dot(toLight, toLight);  // Quadrat statt length()\n    vec3 lightVec = toLight * inversesqrt(dist2);\n    \n    float spotEffect = dot(lightVec, -light.dir);\n    float spotCutoff = cos(light.angle);\n    \n    if (spotEffect < spotCutoff) return vec3(0.0);\n    \n    float edge = smoothstep(spotCutoff, 1.0, spotEffect);\n    float dist = sqrt(dist2);\n    float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist2);\n    \n    return light.color * (edge * attenuation * fog * light.intensity);\n}\n\n// Optimiertes Ray Marching\nvec3 volumetricLighting(vec3 ro, vec3 rd, float maxDist, Light lights[NUM_LIGHTS]) {\n    vec3 color = vec3(0.0);\n    \n    // Adaptive Schrittweite\n    float stepSize = maxDist / float(MAX_STEPS);\n    stepSize = max(stepSize, 0.15);  // Minimum 0.15\n    \n    float t = stepSize * 0.5;  // Start mit halber Schrittweite (besseres Sampling)\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (t >= maxDist) break;\n        \n        vec3 pos = ro + rd * t;\n        \n        // Fog nur einmal pro Schritt berechnen\n        float fog = 0.1 + noise(pos * 0.5 + vec3(0.0, -iTime * 0.1, 0.0)) * 0.05;\n        \n        // Alle Lichter akkumulieren\n        vec3 lightContrib = vec3(0.0);\n        for (int j = 0; j < NUM_LIGHTS; j++) {\n            lightContrib += spotlightFast(pos, lights[j], fog);\n        }\n        \n        color += lightContrib;\n        t += stepSize;\n    }\n    \n    return color * stepSize;\n}\n\nfloat groundPlane(vec3 ro, vec3 rd) {\n    return rd.y < 0.0 ? -ro.y / rd.y : -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Lichter einmal pro Pixel vorberechnen\n    Light lights[NUM_LIGHTS];\n    setupLights(lights);\n    \n    // Camera\n    vec3 ro = vec3(0.0, 1.5, 5.0);\n    vec3 forward = normalize(vec3(0.0, 1.0, 0.0) - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Background\n    vec3 color = vec3(0.02, 0.02, 0.05) * (1.0 - uv.y * 0.5);\n    \n    // Ground\n    float groundT = 0.0;\n    if(showGround >= 0.5){\n    groundT = groundPlane(ro, rd);\n    if (groundT > 0.0) {\n        vec3 groundPos = ro + rd * groundT;\n        vec2 checker = floor(groundPos.xz * 2.0);\n        float pattern = mod(checker.x + checker.y, 2.0);\n        color = mix(color, mix(vec3(0.05), vec3(0.1), pattern), exp(-groundT * 0.1));\n    }\n    }\n    // Volumetric lighting\n    color += volumetricLighting(ro, rd, groundT > 0.0 ? groundT : 10.0, lights);\n    \n    // Tonemapping + Gamma + Vignette kombiniert\n    color = pow(color / (1.0 + color), vec3(0.4545)) * (1.0 - dot(uv, uv) * 0.3);\n    \n    fragColor = vec4(color, 1.0);\n} ",
          "filePath": null,
          "params": {
            "speed": 1,
            "showGround": 0.5,
            "lightHeight": 0.5,
            "lightDepth": 0.5,
            "light1": [
              1,
              1,
              1
            ],
            "light2": [
              1,
              1,
              1
            ],
            "light3": [
              1,
              1,
              1
            ],
            "light4": [
              1,
              1,
              1
            ],
            "light5": [
              1,
              1,
              1
            ],
            "light6": [
              1,
              1,
              1
            ],
            "light7": [
              1,
              1,
              1
            ],
            "light8": [
              1,
              1,
              1
            ]
          },
          "customParams": {
            "showGround": 0.5,
            "lightHeight": 0.5,
            "lightDepth": 0.5,
            "light1": [
              1,
              1,
              1
            ],
            "light2": [
              1,
              1,
              1
            ],
            "light3": [
              1,
              1,
              1
            ],
            "light4": [
              1,
              1,
              1
            ],
            "light5": [
              1,
              1,
              1
            ],
            "light6": [
              1,
              1,
              1
            ],
            "light7": [
              1,
              1,
              1
            ],
            "light8": [
              1,
              1,
              1
            ]
          },
          "presets": [
            {
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  0.30980392156862746,
                  0.9803921568627451,
                  0.0196078431372549
                ],
                "light2": [
                  1,
                  0,
                  0
                ],
                "light3": [
                  0,
                  0,
                  1
                ],
                "light4": [
                  1,
                  0,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  0
                ],
                "light7": [
                  0,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  1,
                  1,
                  1
                ],
                "light2": [
                  0,
                  1,
                  1
                ],
                "light3": [
                  1,
                  1,
                  1
                ],
                "light4": [
                  1,
                  0,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  1
                ],
                "light7": [
                  1,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  0
                ]
              },
              "name": null
            },
            {
              "params": {
                "speed": 1,
                "showGround": 0.5,
                "lightHeight": 0.5,
                "lightDepth": 0.5,
                "light1": [
                  1,
                  1,
                  1
                ],
                "light2": [
                  1,
                  1,
                  1
                ],
                "light3": [
                  1,
                  1,
                  1
                ],
                "light4": [
                  1,
                  1,
                  1
                ],
                "light5": [
                  1,
                  1,
                  1
                ],
                "light6": [
                  1,
                  1,
                  1
                ],
                "light7": [
                  1,
                  1,
                  1
                ],
                "light8": [
                  1,
                  1,
                  1
                ]
              },
              "name": null
            }
          ],
          "type": "shader"
        },
        {
          "shaderCode": "// Starfield with fractal geometry\n// Custom params: // @param name type [default] [min, max] \"description\"\n\n#define NUM_LAYERS 10.\n\nmat2 Rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat Star(vec2 uv, float flare) {\n    float col = 0.;\n    float d = length(uv);\n    float m = .02/d;\n    \n    float rays = max(0., 1. - abs(uv.x * uv.y * 500.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0., 1. - abs(uv.x * uv.y * 500.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(1., .2, d);\n\n    return m;\n}\n\nfloat Hash21(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p+25.32);\n  \n  return fract(p.x*p.y);\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for(int y = -1; y <= 1; y++ ) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 offs = vec2(x, y);\n\n            float n = Hash21(id + offs);\n            float size = fract(n*345.32);\n            \n            vec2 p = vec2(n, fract(n*34.));\n            \n            float star = Star(gv - offs - p + .5, smoothstep(.8, 1., size) * .6);\n            \n            vec3 hueShift = fract(n*2345.2 + dot(uv /420.,texture(iChannel0, vec2(0.25, 0.)).rg))*vec3(.2, .3, .9)*123.2;\n\n            vec3 color = sin(hueShift) * .5 + .5;\n            color = color * vec3(1., .25, 1.+size);\n\n            star *= sin(iTime*3.+n*6.2831)*.4+1.;\n            col += star * size * color;\n        }\n    }\n    \n    return col;\n\n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;\n    float t = iTime * .01;\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.) * 3.1415) * .1;\n\n    vec2 n = N((5./6.) * 3.1415);\n    float d = dot(uv - vec2(.5, 0.), n);\n    uv -= n * max(0., d) * 2.;\n\n    // col += smoothstep(.01, .0, abs(d));\n\n    n = N((2./3.) * 3.1415);\n    float scale = 1.;\n    uv.x += 1.0 / 1.25;\n    for(int i=0; i<5; i++) {\n        scale *= 1.25;\n        uv *= 1.25;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n    }\n\n \n    uv += M * 4.;\n\n    uv *= Rot(t);\n    vec3 col = vec3(0.);\n    \n    float layers = 20.;\n    \n    for(float i=0.; i < 1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t);\n        float scale = mix(20., .5, depth);\n        float fade = depth * smoothstep(0., .9, depth);\n        col += StarLayer(uv * scale + i * 453.2) * fade;\n    }\n\n    fragColor = vec4(col,1.0);\n}",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/shadertoy/stars1.glsl",
          "params": {
            "red": 0.65,
            "green": 0.09,
            "blue": 0.21,
            "red2": 1,
            "green2": 1,
            "blue2": 1,
            "red3": 1,
            "green3": 1,
            "blue3": 1,
            "speed": 1,
            "param1": 0.5,
            "param2": 0.5
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Custom params: // @param name type [default] [min, max] \"description\"\n\n/*\n\n    Bumped Sinusoidal Warp\n    ----------------------\n\n    Sinusoidal planar deformation, or the 2D sine warp effect to people \n    like me. The effect has been around for years, and there are\n    countless examples on the net. IQ's \"Sculpture III\" is basically a \n    much more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n    turn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n    the frequency and iteration count in order to make it less busy.\n\n    I also threw in a texture, added point-lit bump mapping, speckles... \n    and that's pretty much it. As for why a metallic surface would be \n    defying\tthe laws of physics and moving like this is anyone's guess. :)\n\n    By the way, I have a 3D version, similar to this, that I'll put up at \n    a later date.\n    \n\n\n    Related examples:\n\n    Fantomas - Plop\n    https://www.shadertoy.com/view/ltSSDV\n\n    Fabrice - Plop 2\n    https://www.shadertoy.com/view/MlSSDV\n\n    IQ - Sculpture III (loosely related)\n    https://www.shadertoy.com/view/XtjSDK\n\n    Shane - Lit Sine Warp (far less code)\n    https://www.shadertoy.com/view/Ml2XDV\n\n*/\n\n\n// Warp function. Variations have been around for years. This is\n// almost the same as Fabrice's version:\n// Fabrice - Plop 2\n// https://www.shadertoy.com/view/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p + 3.)*4.;\n\n    float t = iTime/2.;\n\n    // Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos(p.yx*3. + vec2(t, 1.57))/3.;\n        p += sin(p.yx + t + vec2(1.57, 0))/2.;\n        p *= 1.3;\n    }\n\n    // A bit of jitter to counter the high frequency sections.\n    p += fract(sin(p+vec2(13, 7))*5e5)*.03 - .015;\n\n    return mod(p, 2.) - 1.; // Range: [vec2(-1), vec2(1)]\n    \n}\n\n// Bump mapping function. Put whatever you want here. In this case, \n// we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n    return length(W(p))*.7071; // Range: [0, 1]\n\n}\n\n/*\n// Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) / dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*/\n\nvec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // PLANE ROTATION\n    //\n    // Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    // but feel free to uncomment it.\n    //float th = sin(iTime*0.1)*sin(iTime*0.12)*2.;\n    //float cs = cos(th), si = sin(th);\n    //uv *= mat2(cs, -si, si, cs);\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    //\n    // Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a \n    // bump mapped plane situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); // Surface posion, or hit point. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1)); // Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.2, -1); // Light position - Back from the screen.\n    vec3 sn = vec3(0, 0, -1); // Plane normal. Z pointing toward the viewer.\n \n     \n/*\n    // I deliberately left this block in to show that the above is a simplified version\n    // of a raytraced plane. The \"rayPlane\" equation is commented out above.\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0, 0, -1);\n\n    // Plane normal.\n    vec3 sn = normalize(vec3(cos(iTime)*.25, sin(iTime)*.25, -1));\n    //vec3 sn = normalize(vec3(0, 0, -1));\n    \n    vec3 sp = rayPlane(vec3(0), ro, sn, rd);\n    vec3 lp = vec3(cos(iTime)*.5, sin(iTime)*.25, -1); \n*/    \n    \n    \n    // BUMP MAPPING - PERTURBING THE NORMAL\n    //\n    // Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    // and roll it into a single function, but I wanted to show the workings.\n    //\n    // f - Function value\n    // fx - Change in \"f\" in in the X-direction.\n    // fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4./iResolution.y, 0);\n    \n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy - eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy - eps.yx); // Same for the nearby sample in the Y-direction.\n   \n    // Controls how much the bump is accentuated.\n    const float bumpFactor = .05;\n    \n    // Using the above to determine the dx and dy function gradients.\n    fx = (fx - f)/eps.x; // Change in X\n    fy = (fy - f)/eps.x; // Change in Y.\n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    // By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    // normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    //vec3 grad = vec3(fx, fy, 0);\n    //grad -= sn*dot(sn, grad);\n    //sn = normalize(sn + grad*bumpFactor ); \n    sn = normalize(sn + vec3(fx, fy, 0)*bumpFactor);   \n    // Equivalent to the following.\n    //sn = cross(-vec3(1, 0, fx*bumpFactor), vec3(0, 1, fy*bumpFactor));\n    //sn = normalize(sn);\n   \n    \n    // LIGHTING\n    //\n    // Determine the light direction vector, calculate its distance, then normalize it.\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld), .0001);\n    ld /= lDist;\n\n    // Light attenuation.    \n    float atten = 1./(1. + lDist*lDist*.15);\n    //float atten = min(1./(lDist*lDist*1.), 1.);\n    \n    // Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    // find it gives extra depth.\n    atten *= f*.9 + .1; // Or... f*f*.7 + .3; //  pow(f, .75); // etc.\n\n    \n\n    // Diffuse value.\n    float diff = max(dot(sn, ld), 0.);  \n    // Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 4.)*.66 + pow(diff, 8.)*.34; \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 12.); \n    //float spec = pow(max(dot(normalize(ld - rd), sn), 0.), 32.);\n    \n    \n    // TEXTURE COLOR\n    //\n    // Combining the surface postion with a fraction of the warped surface position to index \n    // into the texture. The result is a slightly warped texture, as a opposed to a completely \n    // warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    // so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    // it's more readable this way.\n    vec3 texCol = texture(iChannel0, sp.xy + W(sp.xy)/8.).xyz; \n    texCol *= texCol; // Rough sRGB to linear conversion... That's a whole other conversation. :)\n    // A bit of color processing.\n    texCol = smoothstep(.05, .75, pow(texCol, vec3(.75, .8, .85)));    \n    \n    // Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    //vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .2;\n    \n    \n    \n    // FINAL COLOR\n    // Using the values above to produce the final color.   \n    vec3 col = (texCol*(diff*vec3(1, .97, .92)*2. + .5) + vec3(1, .6, .2)*spec*2.)*atten;\n    \n    // Faux environment mapping: I added this in at a later date out of sheer boredome, and  \n    // because I like shiny stuff. You can comment it out if it's not to your liking. :)\n    float ref = max(dot(reflect(rd, sn), vec3(1)), 0.);\n    col += col*pow(ref, 4.)*vec3(.25, .5, 1)*3.;\n    \n\n    // Perform some statistically unlikely (but close enough) 2.0 gamma correction. :) \n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/shadertoy/fluessig1.frag",
          "params": {
            "speed": 1.22,
            "p0": 0.05,
            "p1": 0.49,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 0,
            "g0": 0,
            "b0": 0,
            "r1": 0,
            "g1": 0,
            "b1": 0,
            "r2": 0,
            "g2": 0,
            "b2": 0,
            "r3": 0,
            "g3": 0,
            "b3": 0,
            "r4": 0,
            "g4": 0,
            "b4": 0,
            "r5": 0,
            "g5": 0,
            "b5": 0,
            "r6": 0,
            "g6": 0,
            "b6": 0,
            "r7": 0,
            "g7": 0,
            "b7": 0,
            "r8": 0,
            "g8": 0,
            "b8": 0,
            "r9": 0,
            "g9": 0,
            "b9": 0
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Colorful flames effect\n// Custom params: // @param name type [default] [min, max] \"description\"\n\n#define R iResolution.xy\n#define S smoothstep\n#define T texture\n\nvec3 flame (vec2 u, float s, vec3 c1, vec3 c2) {\n    float y = S(-.6,.6,u.y);\n    u += T(iChannel0, u*.02 + vec2(s - iTime*.03, s - iTime*.1)).r * y * vec2(0.7, 0.2);\n    float f = S(.1, 0., length(u) - .4);\n    f *= S(0., 1., length(u + vec2(0., .35)));\n    return f*mix(c1,c2,y);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 u = (I-.5*R)/R.y*vec2(10.,1.3);\n    \n    vec3 f1 = flame(u+vec2( 7.5,0.2),.1,vec3(.9,.4,.1),vec3(.9,.7,.3));\n    vec3 f2 = flame(u+vec2( 6.,0.),.2,vec3(.2,.6,.7),vec3(.6,.8,.9));\n    vec3 f3 = flame(u+vec2( 4.5,0.),.3,vec3(.9,.0,.0),vec3(.9,.3,.0));\n    vec3 f4 = flame(u+vec2( 3.,0.),.4,vec3(.2,.3,.8),vec3(.9,.6,.9));\n    vec3 f5 = flame(u+vec2( 1.5,0.),.5,vec3(.9,.4,.6),vec3(.9,.7,.3));\n    vec3 f6 = flame(u+vec2( 0.,0.),.6,vec3(.2,.6,.7),vec3(.6,.8,.9));\n    vec3 f7 = flame(u+vec2( -1.5,0.),.7,vec3(.9,.4,.3),vec3(1.,.8,.5));\n    vec3 f8 = flame(u+vec2(-3.,0.),.8,vec3(.2,.3,.8),vec3(.9,.6,.9));\n\n    vec3 C = f1+f2+f3+f4+f5+f6+f7+f8;\n    O = vec4(C+C,1.0);\n}",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/shadertoy/flames.glsl",
          "params": {
            "speed": 1.22,
            "p0": 0.05,
            "p1": 0.49,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Fractal tunnel effect\n// Based on shader from coyote => https://www.shadertoy.com/view/ltfGzS\n// Custom params: // @param name type [default] [min, max] \"description\"\n// @param roomColor color [1.0, 0.3, 0.1] \"Fire color\"\n// matrix op\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\n//mat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n    float t = iDate.w*.2, c,d,m;\n    vec3 p=vec3((2.*fragCoord.xy-s)/s.x,1.),r=p-p,q=r;\n    //p*=getRotZMat(-t);\n    p*=getRotYMat(-t);\n   \tq.zx += 10.+vec2(sin(t),cos(t))*3.;\n    for (float i=1.; i>0.; i-=.01) {\n        c=d=0.,m=1.;\n\t\tfor (int j = 0; j < 3 ; j++)\n            r=max(r*=r*=r*=r=mod(q*m+1.,2.)-1.,r.yzx),\n            d=max(d,( .29 -length(r)*.6)/m)*.8,\n            m*=1.1;\n\n        q+=p*d;\n        \n        c = i;\n\t    \n        if(d<1e-5) break;\n    }\n    \n    float k = dot(r,r+.15);\n    fragColor.rgb = vec3(1.,k,k/c) - (1. - roomColor);\n    \n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {
            "roomColor": [
              1,
              1,
              1
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n *\n * Supported types: int, float, vec2, vec3, vec4, color\n *\n * Examples:\n *   // @param speed float 1.0 [0.0, 2.0] \"Animation speed\"\n *   // @param center vec2 0.5, 0.5 \"Center position\"\n *   // @param tint color [1.0, 0.5, 0.0] \"Tint color\"\n */\n\nvec3 palette(float d){\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.89);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n/*\n    \"Artifacts\" by @XorDev\n    \n    https://x.com/XorDev/status/2008361514684539306\n*/\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Iterator, raymarch depth and step distance\n    float i, z, d;\n    \n    //Raymarch sample point\n    vec3 p;\n    \n    //Clear fragColor and raymarch 77 steps\n    for(O*=i; i++<77.;\n        //Slowly step forward using the distance to a distorted z-plane\n        z += d = abs(p.z/30.+.2),\n        //Add color (attenuating with distance to surface)\n        O += vec4(z,z,9,1) / d,\n        //Compute the next sample point\n        p = z * normalize(vec3(I+I,0) - iResolution.xyy),\n        //Shift diagonally\n        p.xy += iTime)\n        \n        //Use blocky \"turbulence\" for the distortion\n        //https://mini.gmshaders.com/p/turbulence\n        for(d=0.; d++<9.; p+=sin(round(p)+d*3.).zxy);\n        \n    //Tanh tonemapping\n    //https://mini.gmshaders.com/p/func-tanh\n    O = tanh(O/8e4);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n// genuary: Lights on/off. Make something that changes when you switch on or off the “digital” lights.\n\n// flight path, given z, get xy\n#define P(z) vec3(cos((z)*.01)*164.,cos((z)*.012)*164., z)\n\n// MENGERLAYER\n#define m(f, h)\\\n    s /= (f), \\\n    p = abs(fract(q/s)*s - s*.5), \\\n \td = min(d, min(max(p.x, p.y), \\\n               min(max(p.y, p.z), \\\n               max(p.x, p.z))) - s/(h))\n\nvoid mainImage(out vec4 o, vec2 u) {\n   \n    float i, T = iTime,d,s = 1.275,\n          j = (.05*dot(fract(sin(.7*T+u)), sin(u))),\n          f;\n    vec3  c,r = iResolution;\n    mat2 rot = mat2(cos(cos(T*.06)*4.+vec4(0,33,11,0)));\n    \n    // scale coords\n    u = (u+u - r.xy) / r.y;\n\n    // cinema bars\n    if (abs(u.y) > .75) { o = vec4(0); return; }\n    \n    // look around\n    u += vec2( sin(iTime)*.5, sin(iTime*.5)*.5 );\n    \n    // on-off frequency, changes color, too\n    f = (1.+tanh(cos(sin(T*T)*.05+T*.3)*3.)*13.);\n    \n    // set up ray origin, dir, look-at\n    vec3  q,p = P(T*32.),\n          Z = normalize( P(T*32.+4.) - p),\n          X = normalize(vec3(Z.z,0,-Z)),\n          D = vec3(rot*u, 1) * mat3(-X, cross(X, Z), Z);\n \n    for(;i++ < 64.;\n        // add grayscale color and foggy border\n        c += s + .4*dot(u,u) - f/s\n    )\n        // raymarch position\n        q = p += j + D * s,\n        // can play with initial dist (d) and scale (s)\n        d=9e9,s=2e2,\n\n        // apply some menger layers\n        m(1., 3.),\n        m(2., 4.),\n        m(9., 4.),\n        p += cos(p.yzx) * 1e1,\n        // -1 to 1 + min(gyroid, menger);\n        s = .02+.5*abs(sin(p.z*.2)+min(dot(sin(q/236.), cos(q.yzx/166.))*5., d)),\n        // restore p (m() macro modifies it)\n        p = q;\n    \n    \n    // tanh tone map, colorize, divide brightness\n    o.rgb = tanh(vec3(f,2,3)*c/1e4);\n\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n#define A 9. // amplitude\n#define T (iTime/3e2)\n#define H(a) (cos(radians(vec3(180, 90, 0))+(a)*6.2832)*.5+.5)  // hue\n\nfloat map(vec3 u, float v)  // sdf\n{\n    float t = T,     // speed\n          l = 5.,    // loop to reduce clipping\n          f = 1e10, i = 0., y, z;\n    \n    u.xy = vec2(atan(u.x, u.y), length(u.xy));  // polar transform\n    u.x += t*v*3.1416*.7;  // counter rotation\n    \n    for (; i++<l;)\n    {\n        vec3 p = u;\n        y = round((p.y-i)/l)*l+i;\n        p.x *= y;\n        p.x -= y*y*t*3.1416;\n        p.x -= round(p.x/6.2832)*6.2832;\n        p.y -= y;\n        z = cos(y*t*6.2832)*.5 +.5;  // z wave\n        f = min(f, max(length(p.xy), -p.z -z*A) -.1 -z*.2 -p.z/1e2);  // tubes\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec2 R = iResolution.xy, j,\n         M = iMouse.xy,\n         m = (M -R/2.)/R.y;\n    \n    if (iMouse.z < 1. && M.x+M.y < 10.) m = vec2(0, .5);\n    \n    vec3 o = vec3(0, 0, -130.),  // camera\n         u = normalize(vec3(U -R/2., R.y)),  // 3d coords\n         c = vec3(0),\n         p, k;\n    \n    float t = T,\n          v = -o.z/3.,  // pattern scale\n          i = 0., d = i,\n          s, f, z, r;\n    \n    bool b;\n    \n    for (; i++<70.;)  // raymarch\n    {\n        p = u*d +o;\n        p.xy /= v;           // scale down\n        r = length(p.xy);    // radius\n        z = abs(1. -r*r);    // z warp\n        b = r < 1.;          // inside?\n        if (b) z = sqrt(z);\n        p.xy /= z+1.;        // spherize\n        p.xy -= m;           // move with mouse\n        p.xy *= v;           // scale back up\n        p.xy -= cos(p.z/8. +t*3e2 +vec2(0, 1.5708) +z/2.)*.2;  // wave along z\n        \n        s = map(p, v);  // sdf\n        \n        r = length(p.xy);                  // new r\n        f = cos(round(r)*t*6.2832)*.5+.5;  // multiples\n        k = H(.2 -f/3. +t +p.z/2e2);       // color\n        if (b) k = 1.-k;                   // flip color\n        \n        // this stuff can go outside the raymarch,\n        // but accumulating it here produces softer edges\n        c += min(exp(s/-.05), s)        // shapes\n           * (f+.01)                    // shade pattern\n           * min(z, 1.)                 // darken edges\n           * sqrt(cos(r*6.2832)*.5 +.5) // shade between rows\n           * k*k;                       // color\n        \n        d += s*clamp(z, .3, .9);  // smaller steps towards sphere edge\n        if (s < 1e-3 || d > 1e3) break;\n    }\n    \n    // c += texture(iChannel0, u*d +o).rrr * vec3(0, .4, s)*s*z*.03;  // wavy aqua\n    c += min(exp(-p.z -f*A)*z*k*.01/s, 1.);  // light tips\n        \n    j = p.xy/v +m;  // 2d coords\n    c /= clamp(dot(j, j)*4., .04, 4.);  // brightness\n    \n    C = vec4(exp(log(c)/2.2), 1);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// @param cColor color [1.0, 0.3, 0.1] \"Fire color\"\n// @param rradius float 0.5 [0.0, 1.0] \"radius\"\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to 0-1 range\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Grid parameters\n    float gridSize = 10.0;\n    float radius = rradius * 0.1;\n    \n    // Scale UV to grid space (0 to 10)\n    vec2 gridUV = uv * gridSize;\n    \n    // Get the cell index (0-9) and position within cell (0-1)\n    vec2 cellIndex = floor(gridUV);\n    vec2 cellUV = fract(gridUV);\n    \n    // Center of each cell is at (0.5, 0.5) in cell space\n    // Convert radius to cell space (cell is 1/10 of screen, so radius * 10)\n    float cellRadius = radius * gridSize;\n    \n    // Distance from center of cell\n    float dist = distance(cellUV, vec2(0.5));\n    \n    // Draw circle: white inside, black outside\n    float circle = step(cellRadius, dist);\n    \n    // Output color\n    vec3 color = cColor - vec3(circle);\n    \n    fragColor = vec4(color, 1.0);\n}\n",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {
            "cColor": [
              1,
              1,
              1
            ],
            "rradius": 0.5
          },
          "presets": [],
          "type": "shader"
        }
      ]
    },
    {
      "name": "Special",
      "slots": [
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n// CC0: Clearly a bug\n//   A \"Happy Accident\" Shader\n\n//  Twigl: https://twigl.app?ol=true&ss=-OUOudmBPJ57CIb7rAxS\n\n// This shader uses a technique called \"raymarching\" to render 3D\n// Think of it like casting rays from your eye through each pixel into a 3D world,\n// then stepping along each ray until we hit something interesting.\n//\n// Key concepts for C developers:\n// - vec4/vec3/vec2: Like structs with x,y,z,w components (SIMD-style)\n// - Swizzling: p.xy means \"give me just the x,y parts of vector p\"\n// - mat2(): Creates a 2x2 rotation matrix from an angle\n// - All math operations work on vectors component-wise\n//\n// ATTRIBUTION: Shader techniques inspired by (alphabetical):\n//   @byt3_m3chanic\n//   @FabriceNeyrat2\n//   @iq\n//   @shane\n//   @XorDev\n//   + many more\n\nvoid mainImage(out vec4 O, vec2 C) {\n  float \n      i     // Loop counter (starts at 0)\n    , d     // Distance to nearest surface\n    , z = fract(dot(C,sin(C)))-.5  // Ray distance + noise for anti-banding\n    ;\n  vec4 \n      o     // Accumulated color/lighting\n    , p     // Current 3D position along ray\n    ;\n  for(\n      vec2 r = iResolution.xy  // Screen resolution\n    ; ++i < 77.                \n    ; z += .6*d                // Step forward (larger steps when far from surfaces)\n    )\n      // Convert 2D pixel to 3D ray direction\n      p = vec4(z*normalize(vec3(C-.5*r,r.y)),.1*iTime)\n      \n      // Move through 3D space over time\n    , p.z += iTime\n    \n      // Save position for lighting calculations\n    , O = p\n    \n      // Apply rotation matrices to create fractal patterns\n      // (These transform the 3D coordinates in interesting ways)\n    , p.xy *= mat2(cos(2.+O.z+vec4(0,11,33,0)))\n      \n      // This was originally a bug in the matrix calculation\n      // The incorrect transformation created an unexpectedly interesting pattern\n      // Bob Ross would call this a \"happy little accident\"\n    , p.xy *= mat2(cos(O+vec4(0,11,33,0)))\n    \n      // Calculate color based on position and space distortion\n      // The sin() creates a nice looking palette, division by dot() creates falloff\n    , O = (1.+sin(.5*O.z+length(p-O)+vec4(0,4,3,6)))\n       / (.5+2.*dot(O.xy,O.xy))\n    \n      // Domain repetition, repeats the single line and the 2 planes infinitely\n    , p = abs(fract(p)-.5)\n    \n      // Calculate distance to nearest surface\n      // This combines a cylinder (length(p.xy)-.125) with 2 planesbox (min(p.x,p.y))\n    , d = abs(min(length(p.xy)-.125,min(p.x,p.y)+1e-3))+1e-3\n    \n      // Add lighting contribution (brighter when closer to surfaces)\n    , o += O.w/d*O\n    ;\n  \n  // tanh() compresses the accumulated brightness to 0-1 range\n  // (Like HDR tone mapping in photography)\n  O = tanh(o/2e4);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "/*\n * ShaderShow - Available Uniforms\n * ================================\n * vec3  iResolution      - Viewport resolution (width, height, 1.0)\n * float iTime            - Playback time in seconds\n * float iTimeDelta       - Time since last frame in seconds\n * int   iFrame           - Current frame number\n * vec4  iMouse           - Mouse pixel coords (xy: current, zw: click)\n * vec4  iDate            - (year, month, day, time in seconds)\n *\n * sampler2D iChannel0-3  - Input textures (image, video, camera, audio, NDI)\n * vec3  iChannelResolution[4] - Resolution of each channel\n *\n * Custom Parameters (@param)\n * --------------------------\n * Define custom uniforms with UI controls using @param comments:\n *   // @param name type [default] [min, max] \"description\"\n * Types: int, float, vec2, vec3, vec4, color\n */\n\n// CC0: A Dead Planet of Silicon Dreams\n//  Had a dream of a planet of AI factories\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float\n  PI=3.141592654\n, TAU=2.*PI\n, OFF=.7           // Change this for some different color themes\n, PR =.66          // How many pyramids should there be?\n, ZZ =11.          // How spread out are the pyramids?\n;\n\nconst vec2\n  // Path parameters\n  PA=vec2(6,1.41)\n, PB=vec2(.056,.035)\n, PO=vec2(25,3.3)\n;\n\nconst vec3\n  BY=HSV2RGB(vec3(.05+OFF,.7,.8))\n, BG=HSV2RGB(vec3(.95+OFF,.6,.3))\n, BW=HSV2RGB(vec3(.55+OFF,.3,2.))\n, BF=HSV2RGB(vec3(.82+OFF,.6,2.))\n, FC=.04*vec3(1,2,0)              // \"Color burn\"\n, LD=normalize(vec3(1,-0.5,3))    // Light dir\n, RN=normalize(vec3(-.1,1,.1))    // Ring normal\n;\n\nconst vec4\n  GG=vec4(vec3(-700,300,1000),400.)  // Gas giant dimensions\n  ;\n\nconst mat2 \n  R=mat2(1.2,1.6,-1.6,1.2)\n;\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nvec3 tanh_approx(vec3 x) {\n  vec3 \n    x2 = x*x\n  ;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat ray_sphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 \n    oc=ro - sph.xyz\n    ;\n  float \n    b=dot(oc, rd)\n  , c=dot(oc, oc)- sph.w*sph.w\n  , h=b*b-c\n  ;\n  if(h<0.) return -1.;\n  return -b-sqrt(h);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat ray_plane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat doctahedron(vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 path(float z) {\n  return vec3(PO+PA*cos(PB*z),z);\n}\n\nvec3 dpath(float z) {\n  return vec3(-PA*PB*sin(PB*z),1);\n}\n\nvec3 ddpath(float z) {\n  return vec3(-PA*PB*PB*cos(PB*z),0);\n}\n\nfloat dfbm(vec3 p) {\n  float\n    d=p.y+.6\n  , a=1.\n  ;\n\n  vec2\n    D=vec2(0)\n  , P=.23*p.xz\n  ;\n\n  vec4\n    o\n  ;\n\n  for(int j=0;j<7;++j) {\n    o=cos(P.xxyy+vec4(11,0,11,0));\n    p=o.yxx*o.zwz;\n    D+=p.xy;\n    // This technique \"borrowed\" from IQ\n    d-=a*(1.+p.z)/(1.+3.*dot(D,D));\n    P*=R;\n    a*=.55;\n  }\n  \n  return d;\n}\n\nfloat dpyramid(vec3 p, out vec3 oo) {\n  vec2\n    n=floor(p.xz/ZZ+.5)\n  ;\n  p.xz-=n*ZZ;\n\n  float\n    h0=hash(n)\n  , h1=fract(9677.*h0)\n  , h =.3*ZZ*h0*h0+0.1\n  , d =doctahedron(p,h)\n  ;\n\n  oo=vec3(1e3,0,0);\n  if(h1<PR) return 1e3;\n  oo=vec3(d,h0,h);\n  return d;\n}\n\nfloat df(vec3 p, out vec3 oo) {\n  p.y=abs(p.y);\n\n  float\n    d0=dfbm(p)\n  , d1=dpyramid(p,oo)\n  , d\n  ;\n  d=d0;\n  d=min(d,d1);\n  return d;\n}\n\nfloat fbm(float x) {\n  float \n    a=1.\n  , h=0.\n  ;\n  \n  for(int i=0;i<5;++i) {\n    h+=a*sin(x);\n    x*=2.03;\n    x+=123.4;\n    a*=.55;\n  }\n  \n  return abs(h);\n}\n\nvec4 render(vec2 p2, vec2 q2) {\n  float\n      d=1.\n    , z=0.\n    , T=iTime*3.\n    ;\n    \n  vec3\n      oo\n    , O=vec3(0)\n    , p\n    , P=path(T)\n    , ZZ=normalize(dpath(T)+vec3(0,-0.1,0))\n    , XX=normalize(cross(ZZ,vec3(0,1,0)+ddpath(T)))\n    , YY=cross(XX,ZZ)\n    , R=normalize(-p2.x*XX+p2.y*YY+2.*ZZ)\n    , Y=(1.+R.x)*BY\n    , S=(1.+R.y)*BW*Y\n    ;\n    \n  vec4\n      M\n    ;\n\n  for(int i=0;i<50&&d>1e-5&&z<2e2;++i) {\n    p=z*R+P;\n    d=df(p,oo);\n    if(p.y>0.) {\n      O+=BG+min(d,9.)*Y;\n    } else {\n      O+=S;\n      oo.x*=9.;\n    }\n\n    O+=\n        mix(.02,1.,.5+.5*sin(iTime+TAU*oo.y))\n      * smoothstep(oo.z*.78,oo.z*.8,abs(p.y))\n      / max(oo.x+oo.x*oo.x*oo.x*oo.x*9.,1e-2)\n      * BF\n      ;\n\n    z+=d*.7;\n  }\n\n  O*=9E-3;\n  \n  if(R.y>0.0) {\n    M=GG;\n    S=M.xyz+P;\n    M.xyz=S;\n    z=d=ray_sphere(P,R,M);\n    \n    Y=vec3(.0);\n    if(z>0.) {\n      p=P+R*z;\n      ZZ=normalize(p-M.xyz);\n      Y+=\n          max(dot(LD,ZZ),0.)\n        * smoothstep(1.0,.89,1.+dot(R,ZZ))\n        * fbm(2e-2*dot(p,RN))\n        ;\n    }\n    M=vec4(RN,-dot(RN,S));\n    z=ray_plane(P,R,M);\n    if(z>0.&&(d>0.&&z<d||d==-1.)) {\n      p=P+R*z;\n      d=distance(S,p);\n      Y+=\n          abs(dot(LD,RN))\n        * step(GG.w*1.41,d)\n        * step(d,GG.w*2.)\n        * fbm(.035*d)\n        ;\n    }\n    Y*=smoothstep(0.0,0.2,R.y);\n    Y+=clamp((hsv2rgb(vec3(OFF-.4*R.y,.5+1.*R.y,3./(1.+800.*R.y*R.y*R.y)))),0.,1.);\n\n    O*=Y;\n  }\n\n  O-=(length(q2)+.2)*FC;\n  O=tanh_approx(O);\n  O=max(O,0.);\n  O=sqrt(O);\n\n  return vec4(O,1);\n}\n\nvoid mainImage(out vec4 O, vec2 C) {\n  vec2\n    r=iResolution.xy\n  , p2=(C+C-r)/r.y\n  , q2=C/r\n  ;\n  O=render(p2,q2);\n}",
          "filePath": null,
          "params": {
            "speed": 1,
            "p0": 0.5,
            "p1": 0.5,
            "p2": 0.5,
            "p3": 0.5,
            "p4": 0.5,
            "r0": 1,
            "g0": 1,
            "b0": 1,
            "r1": 1,
            "g1": 1,
            "b1": 1,
            "r2": 1,
            "g2": 1,
            "b2": 1,
            "r3": 1,
            "g3": 1,
            "b3": 1,
            "r4": 1,
            "g4": 1,
            "b4": 1,
            "r5": 1,
            "g5": 1,
            "b5": 1,
            "r6": 1,
            "g6": 1,
            "b6": 1,
            "r7": 1,
            "g7": 1,
            "b7": 1,
            "r8": 1,
            "g8": 1,
            "b8": 1,
            "r9": 1,
            "g9": 1,
            "b9": 1
          },
          "customParams": {},
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Stage Lights Array Simulation - OPTIMIZED\n// Creates an array of animated stage lights with volumetric fog\n\n// @param showGround float 0.5 [0.0, 1.0] \"Show ground (>0.5)\"\n// @param lightHeight float 0.5 [0.0, 1.0] \"Light height\"\n// @param lightDepth float 0.5 [0.0, 1.0] \"Light depth\"\n// @param light1 color [1.0, 0.0, 0.0] \"Light 1\"\n// @param light2 color [0.0, 1.0, 0.0] \"Light 2\"\n// @param light3 color [0.0, 0.0, 1.0] \"Light 3\"\n// @param light4 color [1.0, 1.0, 0.0] \"Light 4\"\n// @param light5 color [1.0, 0.0, 1.0] \"Light 5\"\n// @param light6 color [0.0, 1.0, 1.0] \"Light 6\"\n// @param light7 color [1.0, 0.5, 0.0] \"Light 7\"\n// @param light8 color [0.5, 0.0, 1.0] \"Light 8\"\n\n#define NUM_LIGHTS 8\n#define PI 3.14159265359\n#define MAX_STEPS 88  // Reduziert von ~100\n\n// Vereinfachte Noise-Funktion\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Schnellerer Noise - weniger Operationen\nfloat noise2(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    float e = hash(n + 113.0);\n    float f1 = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    return mix(mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n               mix(mix(e, f1, f.x), mix(g, h, f.x), f.y), f.z);\n}\n\nfloat noise(vec3 x){\n  return 1.0;\n}\n// Vorberechnete Lichtdaten\nstruct Light {\n    vec3 pos;\n    vec3 dir;\n    vec3 color;\n    float angle;\n    float intensity;\n};\n\n// Lichtparameter einmal pro Frame berechnen\nvoid setupLights(out Light lights[NUM_LIGHTS]) {\n    // Build color array from named parameters\n    vec3 lightColors[NUM_LIGHTS];\n    lightColors[0] = light1;\n    lightColors[1] = light2;\n    lightColors[2] = light3;\n    lightColors[3] = light4;\n    lightColors[4] = light5;\n    lightColors[5] = light6;\n    lightColors[6] = light7;\n    lightColors[7] = light8;\n\n    for (int j = 0; j < NUM_LIGHTS; j++) {\n        float lightIndex = float(j);\n        float phase = lightIndex * PI * 2.0 / float(NUM_LIGHTS);\n        float swing = sin(iTime * 0.5 + phase) * 0.3;\n        float tilt = cos(iTime * 0.7 + phase * 1.5) * 0.2;\n\n        lights[j].pos = vec3(-35.0 + lightIndex * 1.0, 3.0 * lightHeight + 3.0, 10.0 * lightDepth - 10.0);\n        lights[j].dir = normalize(vec3(swing, -0.8 + tilt, 1.0));\n        lights[j].angle = 0.3 + 0.1 * sin(iTime + phase);\n\n        // Flicker\n        float flicker = 0.9 + 0.1 * sin(iTime * 20.0 + lightIndex * 7.0);\n        lights[j].intensity = 2.0 * flicker;\n        lights[j].color = lightColors[j];\n    }\n}\n\n// Optimierte Spotlight-Berechnung\nvec3 spotlightFast(vec3 pos, Light light, float fog) {\n    vec3 toLight = light.pos - pos;\n    float dist2 = dot(toLight, toLight);  // Quadrat statt length()\n    vec3 lightVec = toLight * inversesqrt(dist2);\n    \n    float spotEffect = dot(lightVec, -light.dir);\n    float spotCutoff = cos(light.angle);\n    \n    if (spotEffect < spotCutoff) return vec3(0.0);\n    \n    float edge = smoothstep(spotCutoff, 1.0, spotEffect);\n    float dist = sqrt(dist2);\n    float attenuation = 1.0 / (1.0 + 0.1 * dist + 0.01 * dist2);\n    \n    return light.color * (edge * attenuation * fog * light.intensity);\n}\n\n// Optimiertes Ray Marching\nvec3 volumetricLighting(vec3 ro, vec3 rd, float maxDist, Light lights[NUM_LIGHTS]) {\n    vec3 color = vec3(0.0);\n    \n    // Adaptive Schrittweite\n    float stepSize = maxDist / float(MAX_STEPS);\n    stepSize = max(stepSize, 0.15);  // Minimum 0.15\n    \n    float t = stepSize * 0.5;  // Start mit halber Schrittweite (besseres Sampling)\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (t >= maxDist) break;\n        \n        vec3 pos = ro + rd * t;\n        \n        // Fog nur einmal pro Schritt berechnen\n        float fog = 0.1 + noise(pos * 0.5 + vec3(0.0, -iTime * 0.1, 0.0)) * 0.05;\n        \n        // Alle Lichter akkumulieren\n        vec3 lightContrib = vec3(0.0);\n        for (int j = 0; j < NUM_LIGHTS; j++) {\n            lightContrib += spotlightFast(pos, lights[j], fog);\n        }\n        \n        color += lightContrib;\n        t += stepSize;\n    }\n    \n    return color * stepSize;\n}\n\nfloat groundPlane(vec3 ro, vec3 rd) {\n    return rd.y < 0.0 ? -ro.y / rd.y : -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Lichter einmal pro Pixel vorberechnen\n    Light lights[NUM_LIGHTS];\n    setupLights(lights);\n    \n    // Camera\n    vec3 ro = vec3(0.0, 1.5, 5.0);\n    vec3 forward = normalize(vec3(0.0, 1.0, 0.0) - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Background\n    vec3 color = vec3(0.02, 0.02, 0.05) * (1.0 - uv.y * 0.5);\n    \n    // Ground\n    float groundT = 0.0;\n    if(showGround >= 0.5){\n    groundT = groundPlane(ro, rd);\n    if (groundT > 0.0) {\n        vec3 groundPos = ro + rd * groundT;\n        vec2 checker = floor(groundPos.xz * 2.0);\n        float pattern = mod(checker.x + checker.y, 2.0);\n        color = mix(color, mix(vec3(0.05), vec3(0.1), pattern), exp(-groundT * 0.1));\n    }\n    }\n    // Volumetric lighting\n    color += volumetricLighting(ro, rd, groundT > 0.0 ? groundT : 10.0, lights);\n    \n    // Tonemapping + Gamma + Vignette kombiniert\n    color = pow(color / (1.0 + color), vec3(0.4545)) * (1.0 - dot(uv, uv) * 0.3);\n    \n    fragColor = vec4(color, 1.0);\n} ",
          "filePath": null,
          "params": {
            "speed": 1
          },
          "customParams": {
            "showGround": 0.5,
            "lightHeight": 0.5,
            "lightDepth": 0.5,
            "light1": [
              1,
              1,
              1
            ],
            "light2": [
              1,
              1,
              1
            ],
            "light3": [
              1,
              1,
              1
            ],
            "light4": [
              1,
              1,
              1
            ],
            "light5": [
              1,
              1,
              1
            ],
            "light6": [
              1,
              1,
              1
            ],
            "light7": [
              1,
              1,
              1
            ],
            "light8": [
              1,
              1,
              1
            ]
          },
          "presets": [],
          "type": "shader"
        },
        {
          "shaderCode": "// Stage Lighting Simulator\n// A Three.js scene demonstrating concert/stage lighting effects\n//\n// @param cameraSpeed float 0.002 [0, 0.01] \"Camera rotation speed\"\n// @param movingHeadSpeed float 0.5 [0.1, 2.0] \"Moving head animation speed\"\n// @param ledBarSpeed float 0.3 [0.1, 1.0] \"LED bar color cycle speed\"\n// @param hazeOpacity float 0.4 [0, 1] \"Haze particle opacity\"\n// @param blinderFlashRate float 2.0 [0.5, 5.0] \"Blinder flash rate\"\n// @param spotIntensity float 50 [10, 100] \"Spot light intensity\"\n// @param movingHeadIntensity float 80 [20, 150] \"Moving head intensity\"\n// @param autoRotate int 1 [0, 1] \"Camera auto-rotation\"\n\nfunction setup(THREE, canvas, params, channels, mouse) {\n  // Scene setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x050508);\n  scene.fog = new THREE.FogExp2(0x050508, 0.015);\n\n  const camera = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 1000);\n  camera.position.set(0, 8, 25);\n  camera.lookAt(0, 3, 0);\n\n  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });\n  renderer.setSize(canvas.width, canvas.height, false);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n  // Ambient light (very dim)\n  const ambient = new THREE.AmbientLight(0x111122, 0.3);\n  scene.add(ambient);\n\n  // Stage floor\n  const stageGeo = new THREE.BoxGeometry(30, 0.5, 20);\n  const stageMat = new THREE.MeshStandardMaterial({\n    color: 0x1a1a1a,\n    roughness: 0.8,\n    metalness: 0.2\n  });\n  const stage = new THREE.Mesh(stageGeo, stageMat);\n  stage.position.y = -0.25;\n  stage.receiveShadow = true;\n  scene.add(stage);\n\n  // Back wall\n  const wallGeo = new THREE.BoxGeometry(30, 15, 0.5);\n  const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9 });\n  const backWall = new THREE.Mesh(wallGeo, wallMat);\n  backWall.position.set(0, 7, -10);\n  backWall.receiveShadow = true;\n  scene.add(backWall);\n\n  // Truss system\n  const trussMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 });\n\n  function createTruss(length) {\n    const group = new THREE.Group();\n    const radius = 0.08;\n\n    const positions = [[-0.3, 0.3], [0.3, 0.3], [-0.3, -0.3], [0.3, -0.3]];\n\n    positions.forEach(([y, z]) => {\n      const geo = new THREE.CylinderGeometry(radius, radius, length, 8);\n      geo.rotateZ(Math.PI / 2);\n      const mesh = new THREE.Mesh(geo, trussMat);\n      mesh.position.set(0, y, z);\n      group.add(mesh);\n    });\n\n    const braceCount = Math.floor(length / 2);\n    for (let i = 0; i <= braceCount; i++) {\n      const x = -length/2 + i * (length / braceCount);\n      const ringGeo = new THREE.TorusGeometry(0.35, 0.04, 8, 4);\n      ringGeo.rotateY(Math.PI / 2);\n      const ring = new THREE.Mesh(ringGeo, trussMat);\n      ring.position.x = x;\n      group.add(ring);\n    }\n\n    return group;\n  }\n\n  // Trusses\n  const frontTruss = createTruss(28);\n  frontTruss.position.set(0, 10, 5);\n  scene.add(frontTruss);\n\n  const backTruss = createTruss(28);\n  backTruss.position.set(0, 12, -5);\n  scene.add(backTruss);\n\n  const leftTruss = createTruss(12);\n  leftTruss.rotation.y = Math.PI / 2;\n  leftTruss.position.set(-14, 10, 0);\n  scene.add(leftTruss);\n\n  const rightTruss = createTruss(12);\n  rightTruss.rotation.y = Math.PI / 2;\n  rightTruss.position.set(14, 10, 0);\n  scene.add(rightTruss);\n\n  // Arrays to store animated lights\n  const movingHeads = [];\n  const spotLights = [];\n  const barLights = [];\n\n  // Helper to create volumetric cone\n  function createLightCone(color, angle = 0.4, length = 12) {\n    const coneGeo = new THREE.ConeGeometry(Math.tan(angle) * length, length, 32, 1, true);\n    const coneMat = new THREE.MeshBasicMaterial({\n      color: color,\n      transparent: true,\n      opacity: 0.08,\n      side: THREE.DoubleSide,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false\n    });\n    const cone = new THREE.Mesh(coneGeo, coneMat);\n    cone.rotation.x = Math.PI;\n    cone.position.y = -length / 2;\n    return cone;\n  }\n\n  // Create fixture housing\n  function createFixtureHousing(type = 'spot') {\n    const group = new THREE.Group();\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.7, roughness: 0.3 });\n\n    if (type === 'moving') {\n      const yokeGeo = new THREE.BoxGeometry(0.6, 0.8, 0.15);\n      const yoke = new THREE.Mesh(yokeGeo, housingMat);\n      group.add(yoke);\n\n      const headGroup = new THREE.Group();\n      const headGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.7, 16);\n      headGeo.rotateX(Math.PI / 2);\n      const head = new THREE.Mesh(headGeo, housingMat);\n      headGroup.add(head);\n\n      const lensGeo = new THREE.CircleGeometry(0.3, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.position.z = 0.36;\n      headGroup.add(lens);\n\n      headGroup.position.y = -0.4;\n      group.add(headGroup);\n      group.headGroup = headGroup;\n      group.lens = lens;\n    } else if (type === 'spot') {\n      const bodyGeo = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI;\n      group.add(body);\n\n      const lensGeo = new THREE.CircleGeometry(0.33, 16);\n      const lensMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const lens = new THREE.Mesh(lensGeo, lensMat);\n      lens.rotation.x = Math.PI / 2;\n      lens.position.y = -0.41;\n      group.add(lens);\n    } else if (type === 'par') {\n      const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 12);\n      const body = new THREE.Mesh(bodyGeo, housingMat);\n      body.rotation.x = Math.PI / 2;\n      group.add(body);\n    }\n\n    return group;\n  }\n\n  // SPOT LIGHTS - Front truss\n  const spotColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];\n  for (let i = 0; i < 6; i++) {\n    const x = -12 + i * 4.8;\n    const color = spotColors[i];\n\n    const fixture = createFixtureHousing('spot');\n    fixture.position.set(x, 9.5, 5);\n    fixture.rotation.x = 0.3;\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.spotIntensity, 25, 0.4, 0.5, 1);\n    spot.position.set(x, 9.2, 5);\n    spot.target.position.set(x * 0.3, 0, -2);\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.4, 10);\n    cone.position.set(x, 9.2, 5);\n    cone.rotation.x = 0.3;\n    scene.add(cone);\n\n    spotLights.push({ light: spot, cone, fixture, baseX: x, color });\n  }\n\n  // MOVING HEADS - Back truss\n  const movingColors = [0xff0066, 0x00ffff, 0xff6600, 0x00ff66, 0x6600ff, 0xffff00];\n  for (let i = 0; i < 6; i++) {\n    const x = -10 + i * 4;\n    const color = movingColors[i];\n\n    const fixture = createFixtureHousing('moving');\n    fixture.position.set(x, 11.5, -5);\n    scene.add(fixture);\n\n    const spot = new THREE.SpotLight(color, params.movingHeadIntensity, 30, 0.25, 0.3, 1);\n    spot.position.set(x, 10.8, -5);\n    spot.castShadow = true;\n    spot.shadow.mapSize.width = 512;\n    spot.shadow.mapSize.height = 512;\n    scene.add(spot);\n    scene.add(spot.target);\n\n    const cone = createLightCone(color, 0.25, 14);\n    scene.add(cone);\n\n    movingHeads.push({\n      light: spot,\n      cone,\n      fixture,\n      baseX: x,\n      phase: i * Math.PI / 3,\n      color\n    });\n  }\n\n  // LED BARS\n  function createLEDBar(width, segments) {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(width, 0.15, 0.2);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const segmentWidth = width / segments;\n    const lights = [];\n\n    for (let i = 0; i < segments; i++) {\n      const x = -width/2 + segmentWidth/2 + i * segmentWidth;\n      const ledGeo = new THREE.PlaneGeometry(segmentWidth * 0.8, 0.1);\n      const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });\n      const led = new THREE.Mesh(ledGeo, ledMat);\n      led.position.set(x, 0.08, 0);\n      led.rotation.x = -Math.PI / 2;\n      group.add(led);\n\n      const pointLight = new THREE.PointLight(0xffffff, 2, 4);\n      pointLight.position.set(x, 0.2, 0);\n      group.add(pointLight);\n\n      lights.push({ mesh: led, light: pointLight, index: i });\n    }\n\n    group.lights = lights;\n    return group;\n  }\n\n  const frontBar1 = createLEDBar(8, 12);\n  frontBar1.position.set(-8, 0.1, 8);\n  frontBar1.rotation.x = -0.2;\n  scene.add(frontBar1);\n  barLights.push({ bar: frontBar1, phase: 0 });\n\n  const frontBar2 = createLEDBar(8, 12);\n  frontBar2.position.set(8, 0.1, 8);\n  frontBar2.rotation.x = -0.2;\n  scene.add(frontBar2);\n  barLights.push({ bar: frontBar2, phase: Math.PI });\n\n  const backBar = createLEDBar(20, 24);\n  backBar.position.set(0, 0.1, -8);\n  backBar.rotation.x = 0.8;\n  scene.add(backBar);\n  barLights.push({ bar: backBar, phase: 0, isBack: true });\n\n  // WASH LIGHTS\n  const washColors = [0xff3366, 0x3366ff, 0xff3366, 0x3366ff];\n  const washPositions = [[-14, 10, 4], [-14, 10, -4], [14, 10, 4], [14, 10, -4]];\n\n  washPositions.forEach((pos, i) => {\n    const color = washColors[i];\n    const wash = new THREE.SpotLight(color, 40, 25, 0.8, 0.8, 1);\n    wash.position.set(...pos);\n    wash.target.position.set(0, 0, pos[2] * 0.5);\n    scene.add(wash);\n    scene.add(wash.target);\n\n    const cone = createLightCone(color, 0.8, 12);\n    cone.position.set(...pos);\n    cone.rotation.z = i < 2 ? 0.5 : -0.5;\n    scene.add(cone);\n  });\n\n  // BLINDERS\n  function createBlinder() {\n    const group = new THREE.Group();\n    const housingGeo = new THREE.BoxGeometry(2, 0.8, 0.4);\n    const housingMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7 });\n    const housing = new THREE.Mesh(housingGeo, housingMat);\n    group.add(housing);\n\n    const cells = [];\n    for (let i = 0; i < 4; i++) {\n      const x = -0.75 + i * 0.5;\n      const cellGeo = new THREE.CircleGeometry(0.18, 16);\n      const cellMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });\n      const cell = new THREE.Mesh(cellGeo, cellMat);\n      cell.position.set(x, 0, 0.21);\n      group.add(cell);\n\n      const light = new THREE.SpotLight(0xffffcc, 0, 15, 0.6, 0.5, 1);\n      light.position.set(x, 0, 0.3);\n      light.target.position.set(x, -5, 10);\n      group.add(light);\n      group.add(light.target);\n\n      cells.push({ mesh: cell, light });\n    }\n\n    group.cells = cells;\n    return group;\n  }\n\n  const blinder = createBlinder();\n  blinder.position.set(0, 9.5, 5.3);\n  blinder.rotation.x = 0.4;\n  scene.add(blinder);\n\n  // Haze particles\n  const hazeGeo = new THREE.BufferGeometry();\n  const hazeCount = 2000;\n  const hazePositions = new Float32Array(hazeCount * 3);\n\n  for (let i = 0; i < hazeCount; i++) {\n    hazePositions[i * 3] = (Math.random() - 0.5) * 30;\n    hazePositions[i * 3 + 1] = Math.random() * 15;\n    hazePositions[i * 3 + 2] = (Math.random() - 0.5) * 25;\n  }\n\n  hazeGeo.setAttribute('position', new THREE.BufferAttribute(hazePositions, 3));\n  const hazeMat = new THREE.PointsMaterial({\n    color: 0x666688,\n    size: 0.08,\n    transparent: true,\n    opacity: params.hazeOpacity,\n    blending: THREE.AdditiveBlending\n  });\n  const haze = new THREE.Points(hazeGeo, hazeMat);\n  scene.add(haze);\n\n  return {\n    scene,\n    camera,\n    renderer,\n    objects: {\n      movingHeads,\n      spotLights,\n      barLights,\n      blinder,\n      haze,\n      hazeMat,\n      hazeCount,\n      cameraAngle: 0\n    }\n  };\n}\n\nfunction animate(time, delta, params, objects, mouse, channels) {\n  const { movingHeads, spotLights, barLights, blinder, haze, hazeMat, hazeCount } = objects;\n  const THREE = window.THREE;\n\n  // Update haze opacity from params\n  hazeMat.opacity = params.hazeOpacity;\n\n  // Animate moving heads\n  movingHeads.forEach((mh, i) => {\n    const speed = params.movingHeadSpeed;\n    const pan = Math.sin(time * speed + mh.phase) * 0.8;\n    const tilt = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 0.3 + 0.5;\n\n    if (mh.fixture.headGroup) {\n      mh.fixture.headGroup.rotation.x = tilt;\n      mh.fixture.rotation.y = pan;\n    }\n\n    const targetX = mh.baseX + Math.sin(time * speed + mh.phase) * 8;\n    const targetZ = Math.sin(time * speed * 1.4 + mh.phase * 1.5) * 5;\n    mh.light.target.position.set(targetX, 0, targetZ);\n\n    mh.cone.position.copy(mh.light.position);\n    const dir = new THREE.Vector3().subVectors(mh.light.target.position, mh.light.position).normalize();\n    mh.cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dir);\n\n    // Color cycling\n    const hue = (time * 0.1 + i * 0.1) % 1;\n    const color = new THREE.Color().setHSL(hue, 1, 0.5);\n    mh.light.color = color;\n    mh.light.intensity = params.movingHeadIntensity;\n    mh.cone.material.color = color;\n    if (mh.fixture.lens) mh.fixture.lens.material.color = color;\n  });\n\n  // Animate LED bars\n  const ledSpeed = params.ledBarSpeed;\n  barLights.forEach((bl) => {\n    bl.bar.lights.forEach((led, i) => {\n      const hue = (time * ledSpeed + i * 0.05 + bl.phase) % 1;\n      const brightness = (Math.sin(time * 3 + i * 0.3 + bl.phase) + 1) / 2;\n      const color = new THREE.Color().setHSL(hue, 1, 0.5 * brightness + 0.2);\n      led.mesh.material.color = color;\n      led.light.color = color;\n      led.light.intensity = brightness * 3;\n    });\n  });\n\n  // Blinder flash effect\n  const blinderOn = Math.sin(time * params.blinderFlashRate) > 0.9;\n  blinder.cells.forEach((cell) => {\n    cell.light.intensity = blinderOn ? 100 : 0;\n    cell.mesh.material.color.setHex(blinderOn ? 0xffffff : 0x333322);\n  });\n\n  // Animate spot light intensity\n  spotLights.forEach((sl, i) => {\n    const pulse = (Math.sin(time * 2 + i * 0.5) + 1) / 2;\n    sl.light.intensity = params.spotIntensity * (0.6 + pulse * 0.4);\n    sl.cone.material.opacity = 0.05 + pulse * 0.05;\n  });\n\n  // Haze drift\n  const positions = haze.geometry.attributes.position.array;\n  for (let i = 0; i < hazeCount; i++) {\n    positions[i * 3 + 1] += 0.005;\n    if (positions[i * 3 + 1] > 15) positions[i * 3 + 1] = 0;\n  }\n  haze.geometry.attributes.position.needsUpdate = true;\n\n  // Camera auto-rotation\n  if (params.autoRotate === 1) {\n    objects.cameraAngle += params.cameraSpeed;\n  }\n}\n\nfunction cleanup(objects) {\n  if (objects.haze) {\n    objects.haze.geometry.dispose();\n    objects.hazeMat.dispose();\n  }\n}\n",
          "filePath": "/Users/mbp11/development/ai/anthropic/shadershow/examples/stage-lights.jsx",
          "params": {
            "speed": 1
          },
          "customParams": {},
          "presets": [],
          "type": "scene"
        }
      ]
    }
  ]
}