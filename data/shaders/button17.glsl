{
  "format": "shadershow-shader",
  "version": 1,
  "type": "scene",
  "shaderCode": "// Rolling Dice - Three.js Scene Example\n// A simple dice that continuously rolls across the screen\n\n// @param speed float 1.0 [0.1, 3.0] \"Roll speed\"\n// @param bounceHeight float 0.5 [0.0, 2.0] \"Bounce height\"\n// @param diceSize float 1.0 [0.5, 2.0] \"Dice size\"\n\nfunction setup(THREE, canvas, params) {\n  // Create scene\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(0x1a1a2e);\n\n  // Create camera\n  const camera = new THREE.PerspectiveCamera(\n    60,\n    canvas.width / canvas.height,\n    0.1,\n    1000\n  );\n  camera.position.set(0, 4, 6);\n  camera.lookAt(0, 0, 0);\n\n  // Create renderer\n  const renderer = new THREE.WebGLRenderer({\n    canvas: canvas,\n    antialias: true,\n    preserveDrawingBuffer: true\n  });\n  renderer.setSize(canvas.width, canvas.height, false);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n  // Create dice geometry\n  const diceGeometry = new THREE.BoxGeometry(1, 1, 1);\n\n  // Create materials for each face with dot patterns\n  const diceMaterials = createDiceMaterials(THREE);\n\n  // Create dice mesh\n  const dice = new THREE.Mesh(diceGeometry, diceMaterials);\n  dice.castShadow = true;\n  dice.receiveShadow = true;\n  dice.position.y = 1;\n  scene.add(dice);\n\n  // Create ground plane\n  const groundGeometry = new THREE.PlaneGeometry(20, 20);\n  const groundMaterial = new THREE.MeshStandardMaterial({\n    color: 0x2d3436,\n    roughness: 0.8,\n    metalness: 0.2\n  });\n  const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n  ground.rotation.x = -Math.PI / 2;\n  ground.position.y = 0;\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  // Add grid helper for visual reference\n  const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);\n  gridHelper.position.y = 0.01;\n  scene.add(gridHelper);\n\n  // Lighting\n  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n  scene.add(ambientLight);\n\n  const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);\n  mainLight.position.set(5, 10, 5);\n  mainLight.castShadow = true;\n  mainLight.shadow.mapSize.width = 2048;\n  mainLight.shadow.mapSize.height = 2048;\n  mainLight.shadow.camera.near = 0.5;\n  mainLight.shadow.camera.far = 50;\n  mainLight.shadow.camera.left = -10;\n  mainLight.shadow.camera.right = 10;\n  mainLight.shadow.camera.top = 10;\n  mainLight.shadow.camera.bottom = -10;\n  scene.add(mainLight);\n\n  // Add some colored accent lights\n  const redLight = new THREE.PointLight(0xff6b6b, 0.5, 10);\n  redLight.position.set(-3, 2, 3);\n  scene.add(redLight);\n\n  const blueLight = new THREE.PointLight(0x4ecdc4, 0.5, 10);\n  blueLight.position.set(3, 2, -3);\n  scene.add(blueLight);\n\n  return {\n    scene,\n    camera,\n    renderer,\n    dice,\n    ground\n  };\n}\n\nfunction animate(time, delta, params, objects) {\n  const { dice } = objects;\n  const speed = params.speed || 1.0;\n  const bounceHeight = params.bounceHeight || 0.5;\n  const diceSize = params.diceSize || 1.0;\n\n  // Update dice scale\n  dice.scale.setScalar(diceSize);\n\n  // Rolling animation\n  const rollSpeed = speed * 2;\n  dice.rotation.x += delta * rollSpeed * 3;\n  dice.rotation.z += delta * rollSpeed * 2;\n\n  // Bounce animation\n  const bounceFreq = speed * 2;\n  const bounce = Math.abs(Math.sin(time * bounceFreq)) * bounceHeight;\n  dice.position.y = 0.5 * diceSize + bounce;\n\n  // Slight horizontal movement (rolling back and forth)\n  dice.position.x = Math.sin(time * speed * 0.5) * 2;\n  dice.position.z = Math.cos(time * speed * 0.3) * 1.5;\n\n  // Add slight wobble to rotation based on bounce\n  dice.rotation.y = Math.sin(time * speed) * 0.3;\n}\n\nfunction cleanup(objects) {\n  // Dispose of geometries and materials\n  if (objects.dice) {\n    objects.dice.geometry.dispose();\n    if (Array.isArray(objects.dice.material)) {\n      objects.dice.material.forEach(m => m.dispose());\n    }\n  }\n  if (objects.ground) {\n    objects.ground.geometry.dispose();\n    objects.ground.material.dispose();\n  }\n}\n\n// Helper function to create dice face materials with dots\nfunction createDiceMaterials(THREE) {\n  const faceColors = [\n    0xe74c3c, // 1 - red\n    0xf39c12, // 2 - orange\n    0x2ecc71, // 3 - green\n    0x3498db, // 4 - blue\n    0x9b59b6, // 5 - purple\n    0x1abc9c  // 6 - teal\n  ];\n\n  const dotPatterns = [\n    [[0.5, 0.5]], // 1\n    [[0.25, 0.25], [0.75, 0.75]], // 2\n    [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]], // 3\n    [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]], // 4\n    [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]], // 5\n    [[0.25, 0.25], [0.75, 0.25], [0.25, 0.5], [0.75, 0.5], [0.25, 0.75], [0.75, 0.75]] // 6\n  ];\n\n  // Order for cube faces: +X, -X, +Y, -Y, +Z, -Z\n  // Standard dice: opposite faces sum to 7\n  // So: 1-6, 2-5, 3-4\n  const faceOrder = [2, 5, 1, 6, 3, 4]; // Maps to standard dice layout\n\n  return faceOrder.map((num, index) => {\n    const canvas = document.createElement('canvas');\n    canvas.width = 256;\n    canvas.height = 256;\n    const ctx = canvas.getContext('2d');\n\n    // Fill background\n    ctx.fillStyle = '#' + faceColors[num - 1].toString(16).padStart(6, '0');\n    ctx.fillRect(0, 0, 256, 256);\n\n    // Draw rounded rectangle border\n    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n    ctx.lineWidth = 8;\n    roundRect(ctx, 10, 10, 236, 236, 20);\n    ctx.stroke();\n\n    // Draw dots\n    ctx.fillStyle = '#ffffff';\n    const dots = dotPatterns[num - 1];\n    const dotRadius = 22;\n\n    dots.forEach(([x, y]) => {\n      ctx.beginPath();\n      ctx.arc(x * 256, y * 256, dotRadius, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Add subtle shadow to dots\n      ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n      ctx.lineWidth = 2;\n      ctx.stroke();\n    });\n\n    const texture = new THREE.CanvasTexture(canvas);\n    texture.needsUpdate = true;\n\n    return new THREE.MeshStandardMaterial({\n      map: texture,\n      roughness: 0.4,\n      metalness: 0.1\n    });\n  });\n}\n\n// Helper function to draw rounded rectangle\nfunction roundRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n}\n",
  "params": {
    "speed": 1
  },
  "customParams": {},
  "presets": [],
  "label": null
}